#!/usr/bin/perl
# This file is part of "osis-converters".
# 
# Copyright 2019 John Austin (gpl.programs.info@gmail.com)
#     
# "osis-converters" is free software: you can redistribute it and/or 
# modify it under the terms of the GNU General Public License as 
# published by the Free Software Foundation, either version 2 of 
# the License, or (at your option) any later version.
# 
# "osis-converters" is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with "osis-converters".  If not, see 
# <http://www.gnu.org/licenses/>.


# This script might be loaded on any operating system. So code here
# should be as operating system agnostic as possible and should not 
# rely on non-standard Perl modules. The functions in this file are
# required for bootstrapping osis-converters.

use Encode;
use File::Copy;
use File::Spec;

# Config entries that are defined by CrossWire SWORD standard
@SWORD_CONFIGS = (
  'MATCHES:History_[\d\.]+', 'ModuleName', "Abbreviation", "Description", 
  "DataPath", "ModDrv", "SourceType", "Encoding", "CompressType", "BlockType", 
  "BlockCount", "Versification", "CipherKey", "KeyType", "CaseSensitiveKeys", 
  "GlobalOptionFilter", "Direction", "DisplayLevel", "Font", "Feature", 
  "GlossaryFrom", "GlossaryTo", "PreferredCSSXHTML", "About", "SwordVersionDate", 
  "Version", "MinimumVersion", "Category", "LCSH", "Lang", "InstallSize", 
  "Obsoletes", "OSISVersion", "Companion", "Copyright", 'CopyrightHolder', 
  "CopyrightDate", "CopyrightNotes", "CopyrightContactName", 
  "CopyrightContactNotes", "CopyrightContactAddress", "CopyrightContactEmail", 
  "ShortPromo", "ShortCopyright", "DistributionLicense", "DistributionNotes", 
  "TextSource", "UnlockURL"
);

# Custom SWORD related entries that are used by osis-converters SWORD modules
@SWORD_OC_CONFIGS = ( 
  'Scope', 'KeySort', 'LangSortOrder', 'SearchOption', 'AudioCode'
);

# These are SWORD entries which should NOT be set by the user in the 
# config.conf file, because they are autogenerated by osis-converters
@SWORD_AUTOGEN = (
  'DataPath', 'Category', 'CompressType', 'BlockType', 'SourceType', 
  'OSISVersion', 'GlobalOptionFilter', 'Scope', 'SearchOption', 
  'SwordVersionDate', 'InstallSize'
);

# Valid osis-converters config file entries (in addition to SWORD entries)
@OC_CONFIGS = (
  'MATCHES:TitleSubPublication\\[(?<scope>\S+)\\]$', 
  'MATCHES:ARG_\w+', 'TOC', 'TitleCase', 'TitleTOC', 'CreateFullBible', 
  'CreateSeparateBooks', 'CreateSeparatePubs', 'FullResourceURL', 
  'TranslationTitle', 'CombineGlossaries', 'CombinedGlossaryTitle', 
  'NewTestamentTitle', 'OldTestamentTitle' 
);

# Valid [system] section config entries (these end up as Perl global variables)
@OC_SYSTEM = (
  'REPOSITORY', 'MODULETOOLS_BIN', 'GO_BIBLE_CREATOR', 'SWORD_BIN', 
  'OUTDIR', 'FONTS', 'COVERS', 'EBOOKS', 'DEBUG', 'NO_OUTPUT_DELETE', 
  'VAGRANT'
);

# CrossWire SWORD entries which may be localized by appending _code
@SWORD_LOCALIZABLE_CONFIGS = (
  'MATCHES:History_[\d\.]+', 'Abbreviation', 'Description', 'About', 
  'Copyright', 'CopyrightHolder', 'CopyrightDate', 'CopyrightNotes', 
  'CopyrightContactName', 'CopyrightContactNotes', 'CopyrightContactAddress', 
  'CopyrightContactEmail', 'ShortPromo', 'ShortCopyright', 'DistributionNotes'
);

# Osis-converters entries which contain localized text
@OC_LOCALIZABLE_CONFIGS = (
  'MATCHES:TitleSubPublication\\[(?<scope>\S+)\\]$', 'MATCHES:ARG_\w+Title\d', 
  'CombinedGlossaryTitle', 'NewTestamentTitle', 'OldTestamentTitle' ,
  'TranslationTitle', 'Abbreviation', 'Description', 'About'
);

# CrossWire SWORD configs which may be continued line to line by '\'
@CONTINUABLE_CONFIGS = (
  'About', 'Copyright', 'CopyrightNotes', 'CopyrightContactName', 
  'CopyrightContactNotes', 'CopyrightContactAddress', 'DistributionNotes', 
  'TextSource'
);

# These are config entries which may have multiple values, and their 
# separators. If the separator is </nx> the entry can appear multiple 
# times, and each appearance is an additional array value. All other 
# config entries throughout osis-converters may only have one value per 
# context of the config file, or an error will be given.
%MULTIVALUE_CONFIGS = (
  'GlobalOptionFilter' => '<nx/>', 'Feature' => '<nx/>', 
  'Obsoletes' => '<nx/>', 'AudioCode' => ','
); 

# Default values for config entries which have a default value. A 'doc:'
# value is used to document what certain values mean; used to add
# documentation to a default config.conf file.
%CONFIG_DEFAULTS = (
  'Versification' => 'KJV',         'doc:Versification' => 'is a CrossWire SWORD versification system',
  'Encoding' => 'UTF-8',            'doc:Encoding' => 'osis-converters only supports UTF-8 encoding',
  'TOC' => '2',                     'doc:TOC' => 'is a number from 1 to 3, selecting either \toc1, \toc2 or \toc3 USFM tags be used to generate TOCs',
  'TitleCase' => '1',               'doc:TitleCase' => 'is a number from 0 to 2, selecting letter casing for TOC titles. 0 is as-is, 1 is Like This, 2 is LIKE THIS',
  'TitleTOC' => '2',                'doc:TitleTOC' => 'is a number from 1 to 3, selecting either \toc1, \toc2 or \toc3 USFM tags to be used for generating titles for book ePublications',
  'CreateFullBible' => 'AUTO',      'doc:CreateFullBible' => 'selects whether to create a single ePublication with everything in the OSIS file (true|false|AUTO)',
  'CreateSeparateBooks' => 'AUTO',  'doc:CreateSeparateBooks' => 'selects whether to create separate outputs for each Bible book (true|false|AUTO|<OSIS-book>)',
  'CreateSeparatePubs' => 'AUTO',  'doc:CreateSeparatePubs' => 'selects whether to create separate outputs for each sub-publication within a translation (true|false|AUTO|<scope>)',
  'CombineGlossaries' => 'AUTO',    'doc:CombineGlossaries' => 'Set this to \'true\' to combine all glossaries into one, or false to keep them each as a separate glossary, or \'AUTO\' to let the script decide',
  'FullResourceURL' => 'false',     'doc:FullResourceURL' => 'Separate book ePublications often have broken links to missing books, so this URL, if supplied, will alert users where to get the full publication.',
  'CombinedGlossaryTitle' => 'Glossary DEF',   'doc:CombinedGlossaryTitle' => 'Localized title for the combined glossary in the Table of Contents',
  'NewTestamentTitle' => 'New Testament DEF',  'doc:NewTestamentTitle' => 'Localized title for the New Testament in the Table of Contents',
  'OldTestamentTitle' => 'Old Testament DEF',  'doc:OldTestamentTitle' => 'Localized title for the Old Testament in the Table of Contents',
  'TranslationTitle' => 'English Bible DEF',   'doc:TranslationTitle' => 'Localized title for the entire translation used at the top of eBooks etc.. Might be the language name or the localized name for "The Bible".',
  'Font' => '',
  'Companion' => ''
);

$VAGRANT_HOME = '/home/vagrant';

# Globals for OSIS book abbreviations in KJV order
$OT_BOOKS = "Gen Exod Lev Num Deut Josh Judg Ruth 1Sam 2Sam 1Kgs 2Kgs 1Chr 2Chr Ezra Neh Esth Job Ps Prov Eccl Song Isa Jer Lam Ezek Dan Hos Joel Amos Obad Jonah Mic Nah Hab Zeph Hag Zech Mal";
$NT_BOOKS = "Matt Mark Luke John Acts Rom 1Cor 2Cor Gal Eph Phil Col 1Thess 2Thess 1Tim 2Tim Titus Phlm Heb Jas 1Pet 2Pet 1John 2John 3John Jude Rev";
$OSISBOOKS; {my $bn = 1; foreach my $bk (split(/\s+/, "$OT_BOOKS $NT_BOOKS")) {$OSISBOOKS{$bk} = $bn; $bn++;}}
$OSISBOOKSRE = "$OT_BOOKS $NT_BOOKS"; $OSISBOOKSRE =~ s/\s+/|/g;

# Initializes more global path variables, checks operating system and 
# dependencies, and restarts with Vagrant if necessary. If checking and
# initialization is successful 1 is returned so the script can commence.
sub init_opsys() {
  chdir($INPD);
  
  if (-e "$SCRD/paths.pl") {
    &Warn("UPDATE: Removing outdated file: $SCRD/paths.pl");
    unlink("$SCRD/paths.pl");
  }

  &update_configSystemSection(); # update old config.conf files that are missing the [system] section
  &applySystemCONF(); # this can only be run in init_opsys() without breaking Vagrant VM [system] paths
  
  if ($NO_OUTPUT_DELETE) {$DEBUG = 1;}
  &Debug("osis-converters ".(&runningInVagrant() ? "on virtual machine":"on host").":\n\tSCRD=$SCRD\n\tSCRIPT=$SCRIPT\n\tINPD=$INPD\n");
  
  my $isCompatibleLinux = ($^O =~ /linux/i ? &shell("lsb_release -a", 3):''); # Mint is like Ubuntu but with totally different release info! $isCompatibleLinux = ($isCompatibleLinux =~ /Release\:\s*(14|16|18)\./ms);
  my $haveAllDependencies = ($isCompatibleLinux && &checkDependencies($SCRIPT, $SCRD, $INPD) ? 1:0);
  
  # Start the script if we're already running on a VM and/or have dependencies met.
  if (&runningInVagrant() || ($haveAllDependencies && !$VAGRANT)) {
    if ($haveAllDependencies) {
      return 1;
    }
    elsif (&runningInVagrant()) {
      &ErrorBug("The Vagrant virtual machine does not have the necessary dependancies installed.");
      return 0;
    }
  }
  
  my $vagrantInstallMessage = "
    Install Vagrant and VirtualBox and then re-run osis-converters:
    Vagrant (from https://www.vagrantup.com/downloads.html)
    Virtualbox (from https://www.virtualbox.org/wiki/Downloads)";
  
  # If the user is forcing the use of Vagrant, then start Vagrant
  if ($VAGRANT) {
    if (&vagrantInstalled()) {
      &Note("\nVagrant will be used because \$VAGRANT is set.\n");
      &restart_with_vagrant();
    }
    else {
      &Error("You have VAGRANT=1 in config.conf but Vagrant is not installed.", $vagrantInstallMessage);
    }
    return 0;
  }
  
  # OKAY then, to meet dependancies check if we may use Vagrant and report
  if ($isCompatibleLinux) {
    &Error("Dependancies are not met.", "
You are running a compatible version of Linux, so you have two options:
1) Install the necessary dependancies by running: 
osis-converters\$ sudo provision.sh
2) Run with Vagrant by adding 'VAGRANT=1' to the [system] section 
of config.conf.
NOTE: Option #2 requires that Vagrant and VirtualBox be installed and 
will run slower and use more memory.");
    return 0;
  }
  
  # Then we must use Vagrant, if it's installed
  if (&vagrantInstalled()) {
    &restart_with_vagrant();
    return 0;
  }
  
  &Error("You are not running osis-converters on compatible Linux and do not have vagrant/VirtualBox installed.", $vagrantInstallMessage);
  return 0;
}

# This is only needed to update old osis-converters projects that lack [system] config.conf sections
sub update_configSystemSection($) {
  if (!$CONFFILE || !-e $CONFFILE) {return;}
  if (open(CXF, $READLAYER, $CONFFILE)) {
    while (<CXF>) {if ($_ =~ /^\[system\]/) {return;}}
    close(CXF);
  }
  else {&ErrorBug("update_configSystemSection could not open $CONFFILE for reading.");}
    
  if (open(CXF, $APPENDLAYER, $CONFFILE)) {
    &Warn("UPDATE: config.conf has no [system] section. Updating...");
    &Note("The paths.pl file which was used for various path variables
and settings has now been replaced by the [system] section of the
config.conf file. The paths.pl file will be deleted. Your config.conf
will have a new [system] section. This means you may need to comment out 
or change the OUTPUT entry in config.conf if your output files appear in
an unexpected place.");
    my $df = &getDefaultFile('bible/config.conf', 2);
    if (!$df) {$df = &getDefaultFile('bible/config.conf', 3);}
    my $sys = '';
    if (open(DCF, $READLAYER, $df)) {
      while(<DCF>) {
        if ($sys && $_ =~ /^\[/) {last;}
        if ($sys || $_ =~ /^\[system\]/) {$sys .= $_;}
      }
      close(DCF);
    }
    else {&ErrorBug("update_configSystemSection could not open $df for reading");}
    &Warn("<-UPDATE: Appending to $CONFFILE:\n$sys");
    print CXF "\n$sys";
    close(CXF);
  }
  else {&ErrorBug("update_configSystemSection could not open $CONFFILE for appending");}
}

# Apply the config file 'system' section which contains customized 
# paths to things like fonts and executables (it also contains some 
# settings like $DEBUG). NOTE: applySystemCONF() can only be run from 
# init_opsys(), because two passes are necessary to set proper paths
# when Vagrant is being used.
sub applySystemCONF() {
  # The following host paths are converted to absolute paths which may 
  # later be updated to work on the VM if running in Vagrant.
  my @pathvars = ('MODULETOOLS_BIN', 'GO_BIBLE_CREATOR', 'SWORD_BIN', 'OUTDIR', 'FONTS', 'COVERS', 'REPOSITORY');
  
  foreach my $ce (sort keys %{$CONF}) {
    if ($ce !~ /^system\+(.*)$/) {next;}
    my $e = $1;
    my $ok = 0;
    foreach my $v (@OC_SYSTEM) {if ($v eq $e) {$ok++;}}
    if ($ok) {$$e = $CONF->{$ce};}
    else {&Error("Unrecognized config.conf [system] entry: $e.", 
"Only the following entries are recognized in the config.conf 
system section: ".join(' ', @OC_SYSTEM));}
  }
  
  if (!&runningInVagrant()) {
    # If host, then just make paths absolute (and save .hostinfo for Vagrant when needed)
    foreach my $v (@pathvars) {
      if (!$$v || $$v =~ /^(https?|ftp)\:/) {next;}
      if ($^O =~ /linux/i) {$$v = &expandLinuxPath($$v);}
      if ($$v =~ /^\./) {$$v = File::Spec->rel2abs($$v, $SCRD);}
    }
    if (open(SHL, $WRITELAYER, "$SCRD/.hostinfo")) {
      foreach my $v (@pathvars) {
        if (!$$v || $$v =~ /^(https?|ftp)\:/) {next;}
        my $rel2vhs = File::Spec->abs2rel($$v, &vagrantHostShare());
        $rel2vhs =~ s/\\/\//g; # this relative path is for the Linux VM
        print SHL "\$$v = '$rel2vhs';\n";
      }
      print SHL "1;\n";
      close(SHL);
    }
    else {&ErrorBug("Could not open $SCRD/.hostinfo. Vagrant will not work; check that you have write permission in directory $SCRD.");}
  }
  else {
    # if Vagrant, then read .hostinfo and prepend path to INDIR_ROOT Vagrant share
    require("$SCRD/.hostinfo");
    foreach my $v (@pathvars) {
      if (!$$v || $$v =~ /^(https?|ftp)\:/) {next;}
      $$v = "$VAGRANT_HOME/INDIR_ROOT/$$v";
    }
  }
  
  # Finally set default values when config.conf doesn't specify exedirs
  my %exedirs = (
    'MODULETOOLS_BIN' => "~/.osis-converters/src/Module-tools/bin", 
    'GO_BIBLE_CREATOR' => "~/.osis-converters/GoBibleCreator.245", 
    'SWORD_BIN' => "~/.osis-converters/src/sword/build/utilities"
  );
    
  # The following are installed to certain locations by provision.sh
  if ($^O =~ /linux/i) {
    foreach my $v (sort keys %exedirs) {
      if ($$v) {next;}
      $$v = &expandLinuxPath($exedirs{$v});
    }
  }
  
  # All executable directory paths should end in / or else be empty.
  foreach my $v (sort keys %exedirs) {
    if (!$$v) {next;}
    $$v =~ s/([^\/])$/$1\//;
  }
  
  my $dbgmsg = "system configs ".(&runningInVagrant() ? "on virtual machine":"on host").":\n";
  foreach my $v (@pathvars) {$dbgmsg .= "\t$v = $$v\n";}
  $dbgmsg .= "\tvagantHostShare=".&vagrantHostShare()."\n";
  $dbgmsg .= "\tVAGRANT=$VAGRANT\n\tNO_OUTPUT_DELETE=$NO_OUTPUT_DELETE\n";
  &Debug($dbgmsg, 1);
}

# Read the subdirectories of $dir as sub-publication scopes and return
# a sorted array of scopes. Sorting is either by numerical order if the 
# scopes are prepended with a number, or else by KJV order of the first
# book listed in each scope.
sub getSubPublications($) {
  my $dir = shift;
  
  my $subPubMessage = 
  "The directory name must be a valid scope code, using underscores
  in place of spaces. This scope represents the contents of the sub-
  publication within the subdirectory. The name may be prepended with a 
  2 digit number followed by '_' to order the sub-publications within 
  the translation. For example: '02_Ruth_Esther_Jonah'.";
  
  my @scopes = ();
  if (opendir(DIR, $dir)) {
    my %subPubs;
    my @subs = readdir(DIR);
    close(DIR);
subpub:
    foreach my $sub (@subs) {
      if ($sub =~ /^\./) {next;}
      if (!-d "$dir/$sub") {next;}
      if ($sub =~ /\s/) {
        &Error("Sub-publication directory name cannot contain spaces:\n$dir/$sub", $subPubMessage);
        next subpub;
      }
      if ($sub !~ /^((\d\d)_)?([\w\d\-]+)$/) {
        &Error("Could not parse sub-publication name:\n$dir/$sub", $subPubMessage);
        next subpub;
      }
      my $order = $2; my $scope = $3; $scope =~ s/_/ /g;
      my @books = split(/[\-\s]/, $scope);
      foreach my $bk (@books) {
        if (!defined($OSISBOOKS{$bk})) {
          &Error("Book '$bk' is not an OSIS Bible book abbreviation.", $subPubMessage);
          next subpub;
        }
      }
      if (!$order) {$order = sprintf("%02i", $OSISBOOKS{@books[0]});}
      while (defined($subPubs{$order})) {$order .= "00";}
      $subPubs{$order} = $scope;
    }
    foreach my $s (sort keys %subPubs) {push(@scopes, $subPubs{$s});}
  }
  
  return @scopes;
}

# Read a config.conf file. Return 1 if successful or else 0. Add the conf
# file's entries to entryValueHP. If the rewriteMsgP pointer is provided
# then write to it any entries in conf which were already present with 
# the same value in the entryValueHP hash.
#
# The config.conf file must start with [<main_module_name>] on the 
# first line, followed by either CrossWire SWORD config entries (see 
# https://wiki.crosswire.org/DevTools:conf_Files) or osis-converters 
# specific entries. All of these entries apply to the entire project. 
# Config entries may also be set only for specific parts of the 
# conversion process. This is done by starting a new config section with 
# [<script_name>]. Then the following entries will only apply to that  
# part of the conversion process. It is possible for a particular script  
# to overwrite the value of a general entry, and then this value will  
# only apply during that particular part of the conversion process. The 
# [system] section is special in that it allows the direct setting of 
# global variables used by Perl. But it is applied by applySystemCONF() 
# and NOT by readSetCONF() as for the other config entries.
#
# If the main project has a DICT sub-project, then its config entries 
# should be specified in a [<DICTMOD>] section.
#
# If there are multiple entries with the same name in the same section,
# then their values will be serialized and separated by <nx/>.
#
# For a value to continue from one line to the next, continued lines 
# must end with '\'.
sub readConfFile($$$) {
  my $conf = shift;
  my $entryValueHP = shift;
  my $rewriteMsgP = shift;
  
  if (!open(XCONF, $READLAYER, $conf)) {return 0;}
  my $contiuation;
  my $section = '';
  my %data;

  while(<XCONF>) {
    # ignore comment lines
    if    ($_ =~ /^#/) {next;}
    
    # handle section headings
    elsif ($_ =~ /^\s*\[(.*?)\]\s*$/) {
      my $s = $1;
      $section = ($s eq $MAINMOD ? '':$s);
      # read a ModuleName entry for the 1st section and $data{'ModuleName'}."DICT" section
      if ($. == 1) {$data{'ModuleName'} = $s;}
      elsif ($s eq $data{'ModuleName'}."DICT") {$data{"$s+ModuleName"} = $data{'ModuleName'}."DICT";}
    }
    
    # handle config entries
    elsif ($_ =~ /^\s*(.*?)\s*=\s*(.*?)\s*$/) {
      my $entryName = $1; my $value = $2;
      my $entryFull = ($section && $section ne $data{'ModuleName'} ? "$section+":'').$entryName;
      if (!exists($data{$entryFull})) {$data{$entryFull} = $value;}
      else {
        # if this entry supports multiple values, then append another value
        if (exists($MULTIVALUE_CONFIGS{$entryName})) {
          $data{$entryFull} .= $MULTIVALUE_CONFIGS{$entryName}.$value;
        }
        # otherwise overwrite previous value
        else {
          &Warn("The config.conf entry '$entryFull' appears more than once: was=".$data{$entryFull}.", is now=$value. $_");
          $data{$entryFull} = $value;
        }
      }
      $continuation = ($_ =~ /\\\n/ ? $entryFull:'');
    }
    
    # otherwise this line is part of the last line
    else {
      chomp;
      if ($continuation) {$data{$continuation} .= "\n$_";}
      $continuation = ($_ =~ /\\$/ ? $continuation:'');
    }
  }
  close(XCONF);
  
  my @noneed; # to log any unnecessary config.conf entries
  foreach my $new (sort keys %data) {
    if ($new ne 'ModuleName' && $data{$new} eq $entryValueHP->{$new}) {
      push(@noneed, { 'e' => $new, 'v' => $data{$new} });
    }
    $entryValueHP->{$new} = $data{$new};
  }
  
  if ($rewriteMsgP) {$$rewriteMsgP = join("\n", map($_->{'e'}.'='.$_->{'v'}, @noneed));}
  
  if (!$entryValueHP->{"ModuleName"}) {
		&Error("No module name in $conf.", "Specify the module name on the first line of config.conf like this: [MODNAME]", 1);
	}
  
  #use Data::Dumper; &Log(Dumper($entryValueHP)."\n", 1);
  return 1;
}

sub readSetCONF() {
  # Perl variables from the [system] section of config.conf are only 
  # set by applySystemCONF() and they are NOT set by readSetCONF().

  $CONF = {};
  if (!&readConfFile($CONFFILE, $CONF)) {return 0;}
  
  # Config Defaults
  my $ocConfRE = '('.join('|', @OC_CONFIGS).')';
  foreach my $e (@OC_CONFIGS, @SWORD_CONFIGS) {
    if (exists($CONFIG_DEFAULTS{$e})) {
      if (!exists($CONF->{$e})) {$CONF->{$e} = $CONFIG_DEFAULTS{$e};}
    }
    elsif ($e =~ /$ocConfRE/ && $e !~ /^MATCHES\:/) {&ErrorBug("OC_CONFIGS $e does not have a default value.");}
  }
  
  #use Data::Dumper; &Debug(Dumper($CONF)."\n");
  return 1;
}

# Whereas $CONF is just the raw data of the config.conf file. This 
# function returns the current value of a config parameter according to  
# the present script and module context. It also checks that the
# request is allowable.
sub conf($$$$$) {
  my $entry = shift;
  my $mod = shift;          #optional ($MOD)
  my $script_name = shift;  #optional ($SCRIPT_NAME)
  my $confP = shift;        #optional ($CONF)
  my $allowmissing = shift; #optional ('')
  
  my $confP = ($confP ? $confP:$CONF);
  $mod = ($mod ? $mod:$MOD);
  $script_name = ($script_name ? $script_name:$SCRIPT_NAME);
 
  my $key = '';
  my $isConf = &isValidConfig($entry);
  if (!$isConf) {
    &ErrorBug("Unrecognized config request: $entry");
  }
  elsif ($isConf eq 'system') {
    &ErrorBug("Config request $entry is from the special [system] section; use \$$entry rather than &conf('$entry') to access [system] section values.");
  }
  elsif (exists($confP->{$script_name.'+'.$entry})) {
    $key = $script_name.'+'.$entry;
  }
  elsif ($DICTMOD && $mod eq $DICTMOD && exists($confP->{$mod.'+'.$entry})) {
    $key = $mod.'+'.$entry;
  }
  elsif (exists($confP->{$entry})) {$key = $entry;}
  
  if (!$allowmissing && !$key && $entry !~ /(^ARG_|SubPublication)/) {
    &Error("Failed to find config.conf entry $entry.", "Add $entry=<value> to the appropriate section of the config.conf file.");
  }
  #&Debug("entry=$entry, config-key=$key, value=".$confP->{$key}."\n");
  
  &isValidConfigValue($key, $confP);

  return ($key ? $confP->{$key}:'');
}

sub isValidConfigValue($$) {
  my $fullEntry = shift;
  my $confP = shift;
  
  my $entry = $fullEntry; $entry =~ s/^[^\+]*\+//;
  if ($fullEntry =~ /Title/ && $confP->{$fullEntry} =~ / DEF$/) {
    &Error("Using default value for $fullEntry: '".$confP->{$fullEntry}."'", "Add $entry=<localized-title> to the config.conf file.");
    #use Carp qw(longmess); &Log("Here is the stack trace where $entry was requested:\n".&longmess(), 1);
    return 0;
  }
  
  if ($confP->{$fullEntry} =~ /<nx\/>/ && $MULTIVALUE_CONFIGS{$entry} ne '<nx/>') {
    &Error("It is not allowed to have multiple '$entry' entries in config.conf: ".$confP->{$fullEntry},"Remove all but one '$entry' entries from config.conf.");
    return 0;
  }
  
  return 1;
}


# Returns 0 if $e is not a valid config entry.
# Returns 'sword-autogen' if it is a SWORD auto-generated entry.
# Returns 'sword' if it is an otherwise valid SWORD config.conf entry.
# Returns 'system' if it is a valid [system] config.conf entry.
# Returns 1 otherwise (valid, but not special).
#
# Although the section is not required, supplying it, like: system+FONTS
# allows more complete checking.
sub isValidConfig($) {
  my $e = shift;
  
  my $s = ($e =~ s/^(.*?)\+// ? $1:''); # so that section is not required
  
  # check for system
  foreach my $ce (@OC_SYSTEM) {
    if ($e eq $ce) {
      if ($s && $s ne 'system') {return 0;}
      return 'system';
    }
  }
  if ($s eq 'system') {return 0;}

  # check for autogen
  foreach my $ce (@SWORD_AUTOGEN) {
    if ($e eq $ce) {return 'sword-autogen';}
  }
  
  # check for sword or other-valid
  my @a; push(@a, @SWORD_CONFIGS, @SWORD_OC_CONFIGS, @OC_CONFIGS);
  foreach my $e (@SWORD_LOCALIZABLE_CONFIGS) {
    if ($e =~ /^MATCHES\:/) {push(@a, $e.'(_\w+)');}
    else {push(@a, 'MATCHES:'.$e.'(_\w+)');}
  }
  foreach my $sc (@a) {
    my $r=0;
    my $re;
    if ($sc =~ /^MATCHES\:(.*?)$/) {
      $re = $1;
      if ($e =~ /^$re$/) {$r++;}
    }
    elsif ($e eq $sc) {$r++;}
    if ($r) {
      foreach my $ce (@OC_CONFIGS) {
        if ($ce =~ /^MATCHES\:(.*?)$/) {
          $re = $1;
          if ($e =~ /^$re$/) {
            if (my $s = $+{scope}) { # this will only be defined for TitleSubPublication
              $s =~ s/_/ /g;
              foreach my $scope (@SUB_PUBLICATIONS) {if ($scope eq $s) {return 1;}}
              &Error("Unrecognized sub-publication in: $e", 
                "The sub-publication listed between the brackets must have an sfm subdirectory associated with it.");
              return 0;
            }
            return 1;
          }
        }
        if ($e eq $ce) {return 1;}
      }
      return 'sword';
    }
  }
  
  return 0;
}

# Look for an osis-converters default file or directory in the following 
# places, in order. If a default file is not found, return either '' or 
# throw a stop error if priority was 0 (or null etc.). The file may  
# include a path that (presently) begins with either 'bible/' for Bible  
# module default files or 'dict/' for dictionary module default files,
# or 'childrens_bible/' for childrens' Bibles. The fallback for
# 'childrens_bible' calls is 'bible' if the former does not exist. 
# If priority 1, 2 or 3 is specified, only the location with that 
# priority will be checked:
# priority  location
#    1      Project directory (if bible|dict subdir matches the project type)
#    2      main-project-parent/defaults directory
#    3      osis-converters/defaults directory
#
# NOTE: priority -1 will check all locations in order but will not throw 
# an error upon failure to locate a file.
#
# NOTE: Soft links in the file path are followed, but soft links that 
# are valid on the host will NOT be valid on a VM! To work for the VM, 
# soft links must be valid from the VM's perspective (so they will begin 
# with /vagrant and will be broken on the host, but will work on the VM).
sub getDefaultFile($$$) {
  my $file = shift;
  my $priority = shift;
  my $maininpd = shift; $maininpd = ($maininpd ? $maininpd:$MAININPD);
  
  my $mainmod = $maininpd; $mainmod =~ s/^.*?\/([^\/]+)\/?$/$1/;
  
  my $moduleFile = $file;
  my $fileType = ($moduleFile =~ s/^(childrens_bible|bible|dict)\/// ? $1:'');
  
  my $defaultFile;
  my $checkAll = ($priority != 1 && $priority != 2 && $priority != 3);
  
  my $projectDefaultFile = ($fileType eq 'dict' ? "$maininpd/${mainmod}DICT":$maininpd).'/'.$moduleFile;
  my $mainParent = "$maininpd/..";
  if (($checkAll || $priority == 1) && -e $projectDefaultFile) {
    $defaultFile = $projectDefaultFile;
    &Note("getDefaultFile: (1) Found $file at $defaultFile");
  }
  if (($checkAll || $priority == 2) && -e "$mainParent/defaults/$file") {
    if (!$defaultFile) {
      $defaultFile = "$mainParent/defaults/$file";
      &Note("getDefaultFile: (2) Found $file at $defaultFile");
    }
    elsif ($^O =~ /linux/i && !&shell("diff '$mainParent/defaults/$file' '$defaultFile'", 3)) {
      &Note("(2) Default file $defaultFile is not needed because it is identical to the more general default file at $mainParent/defaults/$file");
    }
  }
  if (($checkAll || $priority == 3) && -e "$SCRD/defaults/$file") {
    if (!$defaultFile) {
      $defaultFile = "$SCRD/defaults/$file";
      &Note("getDefaultFile: (3) Found $file at $defaultFile");
    }
    elsif ($^O =~ /linux/i && !&shell("diff '$SCRD/defaults/$file' '$defaultFile'", 3)) {
      &Note("(3) Default file $defaultFile is not needed because it is identical to the more general default file at $SCRD/defaults/$file");
    }
  }
  if ($fileType eq 'childrens_bible' && !$defaultFile) {return &getDefaultFile("bible/$moduleFile", $priority);}
  if (!$priority && !$defaultFile) {
    &ErrorBug("Default file $file could not be found in any default path; add this file to the osis-converters/defaults directory.", 1);
  }
  return $defaultFile;
}

# Return 1 if dependencies are met for $script and 0 if not
sub checkDependencies($$$$) {
  my $script = shift;
  my $scrd = shift;
  my $inpd = shift;
  my $quiet = shift;
  
  my $logflag = ($quiet ? ($DEBUG ? 2:3):1);

  my @deps;
  if ($script =~ /(sfm2all)/) {
    @deps = ('SWORD_PERL', 'SWORD_BIN', 'XMLLINT', 'GO_BIBLE_CREATOR', 'MODULETOOLS_BIN', 'XSLT2', 'CALIBRE');
  }
  elsif ($script =~ /(update)/) {
    @deps = ('SWORD_PERL', 'XMLLINT', 'MODULETOOLS_BIN', 'XSLT2');
  }
  elsif ($script =~ /(sfm2osis|osis2osis)/) {
    @deps = ('SWORD_PERL', 'XMLLINT', 'MODULETOOLS_BIN', 'XSLT2');
  }
  elsif ($script =~ /osis2sword/) {
    @deps = ('SWORD_PERL', 'SWORD_BIN', 'MODULETOOLS_BIN', 'XSLT2');
  }
  elsif ($script =~ /osis2ebooks/) {
    @deps = ('SWORD_PERL', 'MODULETOOLS_BIN', 'XSLT2', 'CALIBRE');
  }
  elsif ($script =~ /osis2html/) {
    @deps = ('SWORD_PERL', 'MODULETOOLS_BIN', 'XSLT2');
  }
  elsif ($script =~ /osis2GoBible/) {
    @deps = ('SWORD_PERL', 'GO_BIBLE_CREATOR', 'MODULETOOLS_BIN', 'XSLT2');
  }
  
  # XSLT2 also requires that openjdk 10.0.1 is NOT being used 
  # because its Unicode character classes fail with saxonb-xslt.
  my %depsh = map { $_ => 1 } @deps;
  if ($depsh{'XSLT2'}) {push(@deps, 'JAVA');}
  
  my %test;
  $test{'SWORD_BIN'}        = [ &escfile($SWORD_BIN."osis2mod"), "You are running osis2mod: \$Rev: 3431 \$" ]; # want specific version
  $test{'XMLLINT'}          = [ "xmllint --version", "xmllint: using libxml" ]; # who cares what version
  $test{'GO_BIBLE_CREATOR'} = [ "java -jar ".&escfile($GO_BIBLE_CREATOR."GoBibleCreator.jar"), "Usage" ];
  $test{'MODULETOOLS_BIN'}  = [ &escfile($MODULETOOLS_BIN."usfm2osis.py"), "Revision: 491" ]; # check version
  $test{'XSLT2'}            = [ 'saxonb-xslt', "Saxon 9" ]; # check major version
  $test{'JAVA'}             = [ 'java -version', "openjdk version \"10.", 1 ]; # NOT openjdk 10.
  $test{'CALIBRE'}          = [ "ebook-convert --version", "calibre 3" ]; # check major version
  $test{'SWORD_PERL'}       = [ "perl -le 'use Sword; print \$Sword::SWORD_VERSION_STR'", "1.8.900" ]; # check version
  
  my $fail;
  foreach my $p (@deps) {
    if (!exists($test{$p})) {
      &ErrorBug("No test for \"$p\".");
      return 0;
    }
    system($test{$p}[0]." >".&escfile("tmp.txt"). " 2>&1");
    if (!open(TEST, $READLAYER, "tmp.txt")) {
      &ErrorBug("Could not read test output file \"$SCRD/tmp.txt\".");
      return 0;
    }
    my $result; {local $/; $result = <TEST>;} close(TEST); unlink("tmp.txt");
    my $need = $test{$p}[1];
    if (!$test{$p}[2] && $result !~ /\Q$need\E/im) {
      &Error("Dependency $p failed:\n\tRan: \"".$test{$p}[0]."\"\n\tLooking for: \"$need\"\n\tGot:\n$result\n");
      $fail++;
    }
    elsif ($test{$p}[2] && $result =~ /\Q$need\E/im) {
      &Error("Dependency $p failed:\n\tRan: \"".$test{$p}[0]."\"\n\tCannot have: \"$need\"\n\tGot:\n$result\n");
      $fail++;
    }
    #&Note("Dependency $p:\n\tRan: \"".$test{$p}[0]."\"\n\tGot:\n$result");
  }
  
  if ($fail) {
    if (!&runningInVagrant()) {
      &Log("
      SOLUTION: On Linux systems you can try installing dependencies by running:
      $scrd/provision.sh\n\n", 1);
    }
    return 0;
  }
  
  return 1;
}


########################################################################
# Vagrant related functions
########################################################################

# The host share directory cannot be just a Windows drive letter (native 
# or emulated) because Vagrant cannot create a share to the root of a 
# window's drive.
sub vagrantHostShare() {
  if ($INPD !~ /^((?:\w\:|\/\w)?\/[^\/]+)/) {
    die "Error: Cannot parse project path \"$INPD\"\n";
  }
  return $1;
}

sub vagrantInstalled() {
  print "\n";
  my $pass;
  system("vagrant -v >tmp.txt 2>&1");
  if (!open(TEST, $READLAYER, "tmp.txt")) {die;}
  $pass = 0; while (<TEST>) {if ($_ =~ /\Qvagrant\E/i) {$pass = 1; last;}}
  unlink("tmp.txt");

  return $pass;
}

sub restart_with_vagrant() {
  if (!-e "$SCRD/Vagrantcustom" && open(VAGC, $WRITELAYER, "$SCRD/Vagrantcustom")) {
    print VAGC "# NOTE: You must halt your VM for changes to take effect\n
  config.vm.provider \"virtualbox\" do |vb|
    # Set the RAM for your Vagrant VM
    vb.memory = 2560
  end\n";
    close(VAGC);
  }
  
  chdir $SCRD; # Required for the following vagrant commands to work

  # Make sure Vagrant is up, and with the right share(s)
  my @shares;
  push(@shares, &vagrantShare(&vagrantHostShare(), "$VAGRANT_HOME/INDIR_ROOT"));
  $status = (-e "./.vagrant" ? &shell("vagrant status", 3):'');
  if ($status !~ /\Qrunning (virtualbox)\E/i) {
    &vagrantUp(\@shares);
  }
  elsif (!&matchingShares(\@shares)) {
    &shell("vagrant halt", 3);
    &vagrantUp(\@shares);
  }

  my $scriptRel = "/vagrant/".File::Spec->abs2rel($SCRIPT, $SCRD); $scriptRel =~ s/\\/\//g;
  my $inpdRel = File::Spec->abs2rel($INPD, &vagrantHostShare()); $inpdRel =~ s/\\/\//g;
  my $cmd = "vagrant ssh -c \"'$scriptRel' '$VAGRANT_HOME/INDIR_ROOT/$inpdRel'\"";
  print "\nStarting Vagrant with...\n$cmd\n";
  
  # Continue printing to console while Vagrant ssh remains open
  open(VUP, "$cmd |");
  while(<VUP>) {print $_;}
  close(VUP);
}

sub runningInVagrant() {
  return (-e "/vagrant/Vagrantfile" ? 1:0);
}

sub vagrantShare($$) {
  my $host = shift;
  my $client = shift;
  # If the host is Windows, $host must be a native path!
  $host =~ s/^((\w)\:|\/(\w))\//uc($+).":\/"/e;
  $host =~ s/\\/\\\\/g; $client =~ s/\\/\\\\/g; # escape "\"s for use as Vagrantfile quoted strings
  return "config.vm.synced_folder \"$host\", \"$client\"";
}

sub vagrantUp(\@) {
  my $sharesP = shift;
  
  if (!-e "./.vagrant") {mkdir("./.vagrant");}
  
  # Create input/output filesystem shares
  open(VAG, $WRITELAYER, "./Vagrantshares") || die "\nError: Cannot open \"./Vagrantshares\"\n";
  foreach my $share (@$sharesP) {print VAG "$share\n";}
  close(VAG);
  print "
Starting Vagrant...
The first use of Vagrant will automatically download and build a virtual
machine having osis-converters fully installed. This build will take some
time. Subsequent use of Vagrant will run much faster.\n\n";
  open(VUP, "vagrant up |");
  while(<VUP>) {print $_;}
  close(VUP);
}

# returns 1 if all shares match, 0 otherwise
sub matchingShares(\@) {
  my $sharesP = shift;
  
  my %shares; foreach my $sh (@$sharesP) {$shares{$sh}++;}
  open(CSH, $READLAYER, "./Vagrantshares") || return 0;
  while(<CSH>) {
    if ($_ =~ /^(\Qconfig.vm.synced_folder\E\s.*)$/) {$shares{$1}++;}
    foreach my $share (@$sharesP) {if ($_ =~ /^\Q$share\E$/) {delete($shares{$share});}}
  }
  return (keys(%shares) == 0 ? 1:0);
}


########################################################################
# Logging functions
########################################################################

# Report errors that users need to fix
sub Error($$$) {
  my $errmsg = shift;
  my $solmsg = shift;
  my $doDie = shift;
  
  # Solution msgs beginning with <> will only be output once
  if ($solmsg =~ s/^<>//) {if ($ERR_CHECK{$solmsg}) {$solmsg='';} else {$ERR_CHECK{$solmsg}++;}}
  
  # Terms beginning with <- will not have a leading line-break
  my $n1 = ($errmsg =~ s/^<\-// ? '':"\n");

  &Log($n1."ERROR: $errmsg\n", 1);
  if ($solmsg) {&Log("SOLUTION: $solmsg\n", 1);}
  
  if ($doDie) {&Log("Exiting...\n", 1); exit;}
}

# Report errors that are unexpected or need to be seen by osis-converters maintainer
sub ErrorBug($$) {
  my $errmsg = shift;
  my $doDie = shift;
  
  &Log("\nERROR (UNEXPECTED): $errmsg\n", 1);
  
  use Carp qw(longmess);
  &Log(&longmess());
  
  &Log("Report the above unexpected error to osis-converters maintainer.\n\n");
  
  if ($doDie) {&Log("Exiting...\n", 1); exit;}
}

sub Warn($$) {
  my $warnmsg = shift;
  my $checkmsg = shift;
  my $flag = shift;
  
  # Terms beginning with <- will not have a leading line-break
  my $n1 = ($warnmsg =~ s/^<\-// ? '':"\n");
  my $n2 = ($checkmsg =~ s/^<\-// ? '':"\n");
  
  # If either term begins with -> there will be no ending line-break
  my $endbreak = ($warnmsg =~ s/^\->// ? '':"\n");
  $endbreak = ($checkmsg =~ s/^\->// || !$endbreak ? '':"\n");
  
  # Messages beginning with <> will only be output once
  if ($warnmsg  =~ s/^<>//) {if ($WARN_MSG{$warnmsg})    {$warnmsg='';}  else {$WARN_MSG{$warnmsg}++;}}
  if ($checkmsg =~ s/^<>//) {if ($WARN_CHECK{$checkmsg}) {$checkmsg='';} else {$WARN_CHECK{$checkmsg}++;}}

  if ($warnmsg) {
    &Log($n1."WARNING: $warnmsg", $flag);
  }
  if ($checkmsg) {
    &Log($n2."CHECK: $checkmsg", $flag);
  }
  if ($endbreak && ($warnmsg || $checkmsg)) {&Log("\n");}
}

sub Note($$) {
  my $notemsg = shift;
  my $flag = shift;
  
  # If message begins with -> there will be no ending line-break
  my $endbreak = ($notemsg =~ s/^\->// ? '':"\n");
  
  # Messages beginning with <> will only be output once
  if ($notemsg  =~ s/^<>//) {if ($NOTE_MSG{$notemsg}) {$notemsg='';} else {$NOTE_MSG{$notemsg}++;}}
  if (!$notemsg) {return;}
  
  &Log("NOTE: $notemsg$endbreak", $flag);
}

sub Debug($$) {
  my $dbgmsg = shift;
  my $flag = shift;
  
  if ($DEBUG) {&Log("DEBUG: $dbgmsg", ($flag ? $flag:1));}
}

sub Report($$) {
  my $rptmsg = shift;
  my $flag = shift;
  
  # Terms beginning with <- will not have a leading line-break
  my $n1 = ($rptmsg =~ s/^<\-// ? '':"\n");
  
  &Log("$n1$MOD REPORT: $rptmsg\n", $flag);
}

# Log to console and logfile. $flag can have these values:
# -1 = only log file
#  0 = log file (+ console unless $NOCONSOLELOG is set)
#  1 = log file + console (ignoring $NOCONSOLELOG)
#  2 = only console
#  3 = don't log anything
sub Log($$) {
  my $p = shift; # log message
  my $flag = shift;
  
  if ($flag == 3) {return;}
  
  $p =~ s/&lt;/</g; $p =~ s/&gt;/>/g; $p =~ s/&amp;/&/g;
  $p =~ s/&#(\d+);/my $r = chr($1);/eg;
  
  if ($p =~ /ERROR/) {
    my $ne = &conf('ARG_NoErr');
    if ($ne && $p =~ /$ne/) {$p =~ s/ERROR/WARNING/g;}
  }
  
  if ((!$NOCONSOLELOG && $flag != -1) || $flag >= 1 || $p =~ /(ERROR|DEBUG)/ || $LOGFILE eq 'none') {
    print encode("utf8", $p);
  }
  
  if ($flag == 2 || $LOGFILE eq 'none') {return;}
  
  if ($p !~ /ERROR/ && !$DEBUG) {$p = &encodePrintPaths($p);}
  
  if (!$LOGFILE) {$LogfileBuffer .= $p; return;}

  open(LOGF, $APPENDLAYER, $LOGFILE) || die "Could not open log file \"$LOGFILE\"\n";
  if ($LogfileBuffer) {print LOGF $LogfileBuffer; $LogfileBuffer = '';}
  print LOGF $p;
  close(LOGF);
}

sub encodePrintPaths($) {
  my $t = shift;
  
  # $LOCAL needs to be a global, but it cannot be changed by config.conf
  if ($^O =~ /linux/i) {$LOCAL = &expandLinuxPath('~/.osis-converters'); }
  
  # encode these local file paths, from longest to shortest
  my @paths = ('SCRD', 'MAININPD', 'MOD_OUTDIR', 'LOCAL', 'SWORD_BIN', 'XMLLINT', 'MODULETOOLS_BIN', 'XSLT2', 'GO_BIBLE_CREATOR', 'CALIBRE');
  foreach my $path (sort { length $$b <=> length $$a } @paths) {
    if (!$$path) {next;}
    my $rp = $$path;
    $rp =~ s/[\/\\]+$//;
    $t =~ s/\Q$rp\E/\$$path/g;
  }
  
  # since log files are written to MOD_OUTDIR, simplify this further
  $t =~ s/\$MOD_OUTDIR\//.\//g;

  return $t;
}


########################################################################
# Utility functions
########################################################################

sub expandLinuxPath($) {
  my $path = shift;
  if ($^O !~ /linux/i) {&ErrorBug("expandLinuxPath() should only be run on Linux, but opsys is: $^O", 1);}
  my $r = &shell("echo $path", 3);
  chomp($r);
  return $r;
}

sub shortLinuxPath($) {
  my $path = shift;
  $path =~ s/\/\.\//\//g;
  $path =~ s/\/[^\/]+\/\.\.\//\//g;
  return $path;
}

sub escfile($) {
  my $n = shift;
  
  $n =~ s/([ \(\)])/\\$1/g;
  return $n;
}

sub isFolderEmpty($) { 
  my $dirname = shift;
  opendir(my $dh, $dirname) or die "Not a directory"; 
  return scalar(grep { $_ ne "." && $_ ne ".." } readdir($dh)) == 0;
}

sub printInt($) {
  my $in = shift; # a number
  my $b = int(0.5 + $in); # rounded to nearest int
  while($b =~ s/(\d+)(\d\d\d)/$1\,$2/){};
  return $b; # rounded with commas: 45,567,234
}

# Run a Linux shell script. $flag can have these values:
# -1 = only log file
#  0 = log file (+ console unless $NOCONSOLELOG is set)
#  1 = log file + console (ignoring $NOCONSOLELOG)
#  2 = only console
#  3 = don't log anything
sub shell($$) {
  my $cmd = shift;
  my $flag = shift; # same as Log flag
  
  &Log("\n$cmd\n", $flag);
  my $result = decode('utf8', `$cmd 2>&1`);
  &Log($result."\n", $flag);
  
  return $result;
}

sub urlencode {
  my $s = shift;
  $s =~ s/([\Q "<>`#?{}\E])/sprintf("%%%02X", ord($1))/seg;
  return $s;
}

1;
