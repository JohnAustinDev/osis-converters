#!/usr/bin/perl
# This file is part of "osis-converters".
# 
# Copyright 2019 John Austin (gpl.programs.info@gmail.com)
#     
# "osis-converters" is free software: you can redistribute it and/or 
# modify it under the terms of the GNU General Public License as 
# published by the Free Software Foundation, either version 2 of 
# the License, or (at your option) any later version.
# 
# "osis-converters" is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with "osis-converters".  If not, see 
# <http://www.gnu.org/licenses/>.


# This script might be loaded on any operating system. So code here
# should be as operating system agnostic as possible and should not 
# rely on non-standard Perl modules. The functions in this file are
# required for bootstrapping osis-converters.

use strict;
use Encode;
use File::Copy;
use File::Spec;

# Initialized in entry script
our ($SCRIPT, $SCRD);

# Initialized in /scripts/bootstrap.pl 
our ($READLAYER, $WRITELAYER, $APPENDLAYER);
our (@SUB_PUBLICATIONS, $LOGFILE, $SCRIPT_NAME, $CONFFILE, $CONF, $MOD, 
     $INPD, $MAINMOD, $DICTMOD, $MAININPD, $DICTINPD);
     
# config.conf [system] globals initialized in applyCONF_system
our ($REPOSITORY, $MODULETOOLS_BIN, $GO_BIBLE_CREATOR, $SWORD_BIN, 
  $OUTDIR, $FONTS, $COVERS, $EBOOKS, $DEBUG, $NO_OUTPUT_DELETE, 
  $VAGRANT);

# Config entries that are defined by CrossWire SWORD standard
our @SWORD_CONFIGS = (
  'MATCHES:History_[\d\.]+', "Abbreviation", "Description", "DataPath", 
  "ModDrv", "SourceType", "Encoding", "CompressType", "BlockType", 
  "BlockCount", "Versification", "CipherKey", "KeyType", "CaseSensitiveKeys", 
  "GlobalOptionFilter", "Direction", "DisplayLevel", "Font", "Feature", 
  "GlossaryFrom", "GlossaryTo", "PreferredCSSXHTML", "About", "SwordVersionDate", 
  "Version", "MinimumVersion", "Category", "LCSH", "Lang", "InstallSize", 
  "Obsoletes", "OSISVersion", "Companion", "Copyright", 'CopyrightHolder', 
  "CopyrightDate", "CopyrightNotes", "CopyrightContactName", 
  "CopyrightContactNotes", "CopyrightContactAddress", "CopyrightContactEmail", 
  "ShortPromo", "ShortCopyright", "DistributionLicense", "DistributionNotes", 
  "TextSource", "UnlockURL"
);

# Custom SWORD related entries that are used by osis-converters SWORD modules
our @SWORD_OC_CONFIGS = ( 
  'Scope', 'KeySort', 'LangSortOrder', 'SearchOption', 'AudioCode'
);

# These are SWORD entries which should NOT be set by the user in the 
# config.conf file, because they are autogenerated by osis-converters
our @SWORD_AUTOGEN = (
  'DataPath', 'Category', 'CompressType', 'BlockType', 'SourceType', 
  'OSISVersion', 'GlobalOptionFilter', 'Scope', 'SearchOption', 
  'SwordVersionDate', 'InstallSize', 'MinimumVersion', 'CaseSensitiveKeys'
);

# Valid osis-converters config file entries (in addition to SWORD entries)
our @OC_CONFIGS = (
  'MATCHES:TitleSubPublication\[\S+\]', 'MATCHES:GlossaryNavmenuLink\[[1-9]\]',
  'MATCHES:ARG_\w+', 'TOC', 'TitleCase', 'TitleTOC', 'CreateFullBible', 
  'CreateSeparateBooks', 'CreateSeparatePubs', 'FullResourceURL', 
  'TranslationTitle', 'CombineGlossaries', 'CombinedGlossaryTitle', 
  'NewTestamentTitle', 'OldTestamentTitle' 
);

# Valid [system] section config entries (these end up as Perl global variables)
our @OC_SYSTEM = (
  'REPOSITORY', 'MODULETOOLS_BIN', 'GO_BIBLE_CREATOR', 'SWORD_BIN', 
  'OUTDIR', 'FONTS', 'COVERS', 'EBOOKS', 'DEBUG', 'NO_OUTPUT_DELETE', 
  'VAGRANT'
);

# CrossWire SWORD entries which may be localized by appending _code
our @SWORD_LOCALIZABLE_CONFIGS = (
  'MATCHES:History_[\d\.]+', 'Abbreviation', 'Description', 'About', 
  'Copyright', 'CopyrightHolder', 'CopyrightDate', 'CopyrightNotes', 
  'CopyrightContactName', 'CopyrightContactNotes', 'CopyrightContactAddress', 
  'CopyrightContactEmail', 'ShortPromo', 'ShortCopyright', 'DistributionNotes'
);

# Osis-converters entries which contain localized text
our @OC_LOCALIZABLE_CONFIGS = (
  'MATCHES:TitleSubPublication\\[(?<scope>\S+)\\]$', 'MATCHES:ARG_\w+Title\d', 
  'CombinedGlossaryTitle', 'NewTestamentTitle', 'OldTestamentTitle' ,
  'TranslationTitle', 'Abbreviation', 'Description', 'About'
);

# CrossWire SWORD configs which may be continued line to line by '\'
our @CONTINUABLE_CONFIGS = (
  'About', 'Copyright', 'CopyrightNotes', 'CopyrightContactName', 
  'CopyrightContactNotes', 'CopyrightContactAddress', 'DistributionNotes', 
  'TextSource'
);

# These are config entries which may appear multiple times within a 
# config.conf context and thus its value is rather an array of values. 
# All other config entries throughout osis-converters may only have one 
# value per context of the config file, or an error will be given.
our @MULTIVALUE_CONFIGS = ('GlobalOptionFilter', 'Feature', 'Obsoletes'); 

# Default values for config entries which have a default value. A 'doc:'
# value is used to document what certain values mean; used to add
# documentation to a default config.conf file.
our %CONFIG_DEFAULTS = (
  'Versification' => 'KJV',         'doc:Versification' => 'is a CrossWire SWORD versification system',
  'Encoding' => 'UTF-8',            'doc:Encoding' => 'osis-converters only supports UTF-8 encoding',
  'TOC' => '2',                     'doc:TOC' => 'is a number from 1 to 3, selecting either \toc1, \toc2 or \toc3 USFM tags be used to generate TOCs',
  'TitleCase' => '1',               'doc:TitleCase' => 'is a number from 0 to 2, selecting letter casing for TOC titles. 0 is as-is, 1 is Like This, 2 is LIKE THIS',
  'TitleTOC' => '2',                'doc:TitleTOC' => 'is a number from 1 to 3, selecting either \toc1, \toc2 or \toc3 USFM tags to be used for generating titles for book ePublications',
  'CreateFullBible' => 'AUTO',      'doc:CreateFullBible' => 'selects whether to create a single ePublication with everything in the OSIS file (true|false|AUTO)',
  'CreateSeparateBooks' => 'AUTO',  'doc:CreateSeparateBooks' => 'selects whether to create separate outputs for each Bible book (true|false|AUTO|<OSIS-book>)',
  'CreateSeparatePubs' => 'AUTO',  'doc:CreateSeparatePubs' => 'selects whether to create separate outputs for each sub-publication within a translation (true|false|AUTO|<scope>)',
  'CombineGlossaries' => 'AUTO',    'doc:CombineGlossaries' => 'Set this to \'true\' to combine all glossaries into one, or false to keep them each as a separate glossary, or \'AUTO\' to let the script decide',
  'FullResourceURL' => 'false',     'doc:FullResourceURL' => 'Separate book ePublications often have broken links to missing books, so this URL, if supplied, is the URL where the full publication can be found.',
  'CombinedGlossaryTitle' => 'Glossary DEF',   'doc:CombinedGlossaryTitle' => 'Localized title for the combined glossary in the Table of Contents',
  'NewTestamentTitle' => 'New Testament DEF',  'doc:NewTestamentTitle' => 'Localized title for the New Testament in the Table of Contents',
  'OldTestamentTitle' => 'Old Testament DEF',  'doc:OldTestamentTitle' => 'Localized title for the Old Testament in the Table of Contents',
  'TranslationTitle' => 'English Bible DEF',   'doc:TranslationTitle' => 'Localized title for the entire translation used at the top of eBooks etc.. Might be the language name or the localized name for "The Bible".',
  'Font' => '',
  'Companion' => ''
);

our $VAGRANT_HOME = '/home/vagrant';

# Globals for OSIS book abbreviations in KJV order
our $OT_BOOKS = "Gen Exod Lev Num Deut Josh Judg Ruth 1Sam 2Sam 1Kgs 2Kgs 1Chr 2Chr Ezra Neh Esth Job Ps Prov Eccl Song Isa Jer Lam Ezek Dan Hos Joel Amos Obad Jonah Mic Nah Hab Zeph Hag Zech Mal";
our $NT_BOOKS = "Matt Mark Luke John Acts Rom 1Cor 2Cor Gal Eph Phil Col 1Thess 2Thess 1Tim 2Tim Titus Phlm Heb Jas 1Pet 2Pet 1John 2John 3John Jude Rev";
our %OSISBOOKS; {my $bn = 1; foreach my $bk (split(/\s+/, "$OT_BOOKS $NT_BOOKS")) {$OSISBOOKS{$bk} = $bn; $bn++;}}
our $OSISBOOKSRE = "$OT_BOOKS $NT_BOOKS"; $OSISBOOKSRE =~ s/\s+/|/g;

# Initializes more global path variables, checks operating system and 
# dependencies, and restarts with Vagrant if necessary. If checking and
# initialization is successful 1 is returned so the script can commence.
sub init_opsys {

  chdir($INPD);
  
  if (-e "$SCRD/paths.pl") {
    &Warn("UPDATE: Removing outdated file: $SCRD/paths.pl");
    unlink("$SCRD/paths.pl");
  }

  &update_configSystemSection(); # update old config.conf files that are missing the [system] section
  &applyCONF_system(); # this can only be run in init_opsys() without breaking Vagrant VM [system] paths
  
  if ($NO_OUTPUT_DELETE) {$DEBUG = 1;}
  &Debug("osis-converters ".(&runningInVagrant() ? "on virtual machine":"on host").":\n\tSCRD=$SCRD\n\tSCRIPT=$SCRIPT\n\tINPD=$INPD\n");
  
  my $isCompatibleLinux = ($^O =~ /linux/i ? &shell("lsb_release -a", 3):''); # Mint is like Ubuntu but with totally different release info! $isCompatibleLinux = ($isCompatibleLinux =~ /Release\:\s*(14|16|18)\./ms);
  my $haveAllDependencies = ($isCompatibleLinux && &checkDependencies($SCRIPT, $SCRD, $INPD) ? 1:0);
  
  # Start the script if we're already running on a VM and/or have dependencies met.
  if (&runningInVagrant() || ($haveAllDependencies && !$VAGRANT)) {
    if ($haveAllDependencies) {
      return 1;
    }
    elsif (&runningInVagrant()) {
      &ErrorBug("The Vagrant virtual machine does not have the necessary dependancies installed.");
      return 0;
    }
  }
  
  my $vagrantInstallMessage = "
    Install Vagrant and VirtualBox and then re-run osis-converters:
    Vagrant (from https://www.vagrantup.com/downloads.html)
    Virtualbox (from https://www.virtualbox.org/wiki/Downloads)";
  
  # If the user is forcing the use of Vagrant, then start Vagrant
  if ($VAGRANT) {
    if (&vagrantInstalled()) {
      &Note("\nVagrant will be used because \$VAGRANT is set.\n");
      &restart_with_vagrant();
    }
    else {
      &Error("You have VAGRANT=1 in config.conf but Vagrant is not installed.", $vagrantInstallMessage);
    }
    return 0;
  }
  
  # OKAY then, to meet dependancies check if we may use Vagrant and report
  if ($isCompatibleLinux) {
    &Error("Dependancies are not met.", "
You are running a compatible version of Linux, so you have two options:
1) Install the necessary dependancies by running: 
osis-converters\$ sudo provision.sh
2) Run with Vagrant by adding 'VAGRANT=1' to the [system] section 
of config.conf.
NOTE: Option #2 requires that Vagrant and VirtualBox be installed and 
will run slower and use more memory.");
    return 0;
  }
  
  # Then we must use Vagrant, if it's installed
  if (&vagrantInstalled()) {
    &restart_with_vagrant();
    return 0;
  }
  
  &Error("You are not running osis-converters on compatible Linux and do not have vagrant/VirtualBox installed.", $vagrantInstallMessage);
  return 0;
}

# This is only needed to update old osis-converters projects that lack [system] config.conf sections
sub update_configSystemSection {

  if (!$CONFFILE || !-e $CONFFILE) {return;}
  if (open(CXF, $READLAYER, $CONFFILE)) {
    while (<CXF>) {if ($_ =~ /^\[system\]/) {return;}}
    close(CXF);
  }
  else {&ErrorBug("update_configSystemSection could not open $CONFFILE for reading.");}
    
  if (open(CXF, $APPENDLAYER, $CONFFILE)) {
    &Warn("UPDATE: config.conf has no [system] section. Updating...");
    &Note("The paths.pl file which was used for various path variables
and settings has now been replaced by the [system] section of the
config.conf file. The paths.pl file will be deleted. Your config.conf
will have a new [system] section. This means you may need to comment out 
or change the OUTPUT entry in config.conf if your output files appear in
an unexpected place.");
    my $df = &getDefaultFile('bible/config.conf', 2);
    if (!$df) {$df = &getDefaultFile('bible/config.conf', 3);}
    my $sys = '';
    if (open(DCF, $READLAYER, $df)) {
      while(<DCF>) {
        if ($sys && $_ =~ /^\[/) {last;}
        if ($sys || $_ =~ /^\[system\]/) {$sys .= $_;}
      }
      close(DCF);
    }
    else {&ErrorBug("update_configSystemSection could not open $df for reading");}
    &Warn("<-UPDATE: Appending to $CONFFILE:\n$sys");
    print CXF "\n$sys";
    close(CXF);
  }
  else {&ErrorBug("update_configSystemSection could not open $CONFFILE for appending");}
}

# Apply the config file 'system' section which contains customized 
# paths to things like fonts and executables (it also contains some 
# settings like $DEBUG). NOTE: applyCONF_system() can only be run from 
# init_opsys(), because two passes are necessary to set proper paths
# when Vagrant is being used.
sub applyCONF_system {

  no strict "refs";
  
  # The following host paths are converted to absolute paths which may 
  # later be updated to work on the VM if running in Vagrant.
  my @pathvars = ('MODULETOOLS_BIN', 'GO_BIBLE_CREATOR', 'SWORD_BIN', 'OUTDIR', 'FONTS', 'COVERS', 'REPOSITORY');
  
  foreach my $ce (sort keys %{$CONF}) {
    if ($ce !~ /^system\+(.*)$/) {next;}
    my $e = $1;
    my $ok = 0;
    foreach my $v (@OC_SYSTEM) {if ($v eq $e) {$ok++;}}
    if ($ok) {$$e = $CONF->{$ce};}
    else {&Error("Unrecognized config.conf [system] entry: $e.", 
"Only the following entries are recognized in the config.conf 
system section: ".join(' ', @OC_SYSTEM));}
  }
  
  if (!&runningInVagrant()) {
    # If host, then just make paths absolute (and save .hostinfo for Vagrant when needed)
    foreach my $v (@pathvars) {
      if (!$$v || $$v =~ /^(https?|ftp)\:/) {next;}
      if ($^O =~ /linux/i) {$$v = &expandLinuxPath($$v);}
      if ($$v =~ /^\./) {$$v = File::Spec->rel2abs($$v, $SCRD);}
    }
    if (open(SHL, $WRITELAYER, "$SCRD/.hostinfo")) {
      foreach my $v (@pathvars) {
        if (!$$v || $$v =~ /^(https?|ftp)\:/) {next;}
        my $rel2vhs = File::Spec->abs2rel($$v, &vagrantHostShare());
        $rel2vhs =~ s/\\/\//g; # this relative path is for the Linux VM
        print SHL "\$$v = '$rel2vhs';\n";
      }
      print SHL "1;\n";
      close(SHL);
    }
    else {&ErrorBug("Could not open $SCRD/.hostinfo. Vagrant will not work; check that you have write permission in directory $SCRD.");}
  }
  else {
    # if Vagrant, then read .hostinfo and prepend path to INDIR_ROOT Vagrant share
    require("$SCRD/.hostinfo");
    foreach my $v (@pathvars) {
      if (!$$v || $$v =~ /^(https?|ftp)\:/) {next;}
      $$v = "$VAGRANT_HOME/INDIR_ROOT/$$v";
    }
  }
  
  # Finally set default values when config.conf doesn't specify exedirs
  my %exedirs = (
    'MODULETOOLS_BIN' => "~/.osis-converters/src/Module-tools/bin", 
    'GO_BIBLE_CREATOR' => "~/.osis-converters/GoBibleCreator.245", 
    'SWORD_BIN' => "~/.osis-converters/src/sword/build/utilities"
  );
    
  # The following are installed to certain locations by provision.sh
  if ($^O =~ /linux/i) {
    foreach my $v (sort keys %exedirs) {
      if ($$v) {next;}
      $$v = &expandLinuxPath($exedirs{$v});
    }
  }
  
  # All executable directory paths should end in / or else be empty.
  foreach my $v (sort keys %exedirs) {
    if (!$$v) {next;}
    $$v =~ s/([^\/])$/$1\//;
  }
  
  my $dbgmsg = "system configs ".(&runningInVagrant() ? "on virtual machine":"on host").":\n";
  foreach my $v (@pathvars) {$dbgmsg .= "\t$v = $$v\n";}
  $dbgmsg .= "\tvagantHostShare=".&vagrantHostShare()."\n";
  $dbgmsg .= "\tVAGRANT=$VAGRANT\n\tNO_OUTPUT_DELETE=$NO_OUTPUT_DELETE\n";
  &Debug($dbgmsg, 1);
}

# Read the subdirectories of $dir as sub-publication scopes and return
# a sorted array of scopes. Sorting is either by numerical order if the 
# scopes are prepended with a number, or else by KJV order of the first
# book listed in each scope.
sub getSubPublications {
  my $dir = shift;
  
  my $subPubMessage = 
  "The directory name must be a valid scope code, using underscores
  in place of spaces. This scope represents the contents of the sub-
  publication within the subdirectory. The name may be prepended with a 
  2 digit number followed by '_' to order the sub-publications within 
  the translation. For example: '02_Ruth_Esther_Jonah'.";
  
  my @scopes = ();
  if (opendir(DIR, $dir)) {
    my %subPubs;
    my @subs = readdir(DIR);
    close(DIR);
subpub:
    foreach my $sub (@subs) {
      if ($sub =~ /^\./) {next;}
      if (!-d "$dir/$sub") {next;}
      if ($sub =~ /\s/) {
        &Error("Sub-publication directory name cannot contain spaces:\n$dir/$sub", $subPubMessage);
        next subpub;
      }
      if ($sub !~ /^((\d\d)_)?([\w\d\-]+)$/) {
        &Error("Could not parse sub-publication name:\n$dir/$sub", $subPubMessage);
        next subpub;
      }
      my $order = $2; my $scope = $3; $scope =~ s/_/ /g;
      my @books = split(/[\-\s]/, $scope);
      foreach my $bk (@books) {
        if (!defined($OSISBOOKS{$bk})) {
          &Error("Book '$bk' is not an OSIS Bible book abbreviation.", $subPubMessage);
          next subpub;
        }
      }
      if (!$order) {$order = sprintf("%02i", $OSISBOOKS{@books[0]});}
      while (defined($subPubs{$order})) {$order .= "00";}
      $subPubs{$order} = $scope;
    }
    foreach my $s (sort keys %subPubs) {push(@scopes, $subPubs{$s});}
  }
  
  return @scopes;
}

# Read a config.conf file. Return hash pointer to the encoded config
# data if successful or else undef.
#
# The config.conf file must start with [<main_module_name>] on the first 
# line, followed by either CrossWire SWORD config entries or osis-con-
# verters specific entries. All of these entries apply to the entire pro-
# ject. Config entries may also be specified for only specific parts of 
# the conversion process. This is done by starting a new config section 
# with [<script_name>]. Then the following entries will only apply to 
# that part of the conversion process. Any value for a particular script  
# will overwrite the value of a general entry. The [system] section is 
# special in that it allows the direct setting of global variables used 
# by Perl. NOTE: The system section is applied to Perl globals by 
# applyCONF_system().
#
# If the main project has a DICT sub-project, then its config entries 
# should be specified in a [<DICTMOD>] section.
#
# There may by multiple entries for @MULTIVALUE_CONFIGS entries and each 
# of the values will be joined together using <nx/> as separator.
#
# Values of @CONTINUABLE_CONFIGS entries may continue from one line to 
# the next when their line(s) end with '\'.
sub readConfFile {
  my $file = shift;
  
  my $contRE = &configRE(@CONTINUABLE_CONFIGS);
  my $multRE = &configRE(@MULTIVALUE_CONFIGS);
  
  &Note("Reading config.conf: $file");
 
  if (!open(XCONF, $READLAYER, $file)) {return;}
  
  my $continuingEntry = '';
  my $section = '';
  my %conf;
  while(<XCONF>) {
    # ignore comment lines
    if ($_ =~ /^#/) {next;}
    
    elsif ($_ =~ /^\s*$/) {
      $continuingEntry = '';
      next;
    }
    
    # handle section headings
    elsif ($_ =~ /^\s*\[(.*?)\]\s*$/) {
      $section = $1;
      $continuingEntry = '';
      
      if ($. == 1) {
        $conf{'MainmodName'} = $section;
      }
      elsif ($section eq $conf{'MainmodName'}."DICT") {
        $conf{'DictmodName'} = $section;
      }
    }
    
    # handle config entries
    elsif ($_ =~ /^\s*(.+?)\s*=\s*(.*?)\s*$/) {
      my $e = $1; my $v = $2;
      
      my $fullEntry = "$section+$e";
      $continuingEntry = '';
      if (!exists($conf{$fullEntry})) {
        $conf{$fullEntry} = $v;
      }
      else {
        # if this entry supports multiple values, then append another value
        if ($e =~ /$multRE/) {
          $conf{$fullEntry} .= "<nx/>$v";
        }
        # otherwise overwrite previous value
        else {
          &Warn("The config.conf entry '$fullEntry' appears more than once: was=".$conf{$fullEntry}.", is now=$v. $_");
          $conf{$fullEntry} = $v;
        }
      }
      
      # is this entry continuing to next line?
      $continuingEntry = ($conf{$fullEntry} =~ s/\\$/\\\n/ ? $fullEntry:'');
      if ($continuingEntry && $e !~ /$contRE/) {
        &Error("Config entry '$e' must take only a single line.", "Remove all newline characters from this entry's value.");
      }
    }
    
    # is this line part of the previous line?
    elsif ($continuingEntry) {
      chomp;
      $conf{$continuingEntry} .= $_;
      $continuingEntry = ($conf{$continuingEntry} =~ s/\\$/\\\n/ ? $continuingEntry:'');
    }
    else {
      &Error("Unhandled config.conf line: $_");
    }
  }
  close(XCONF);
  
  if (!$conf{"MainmodName"}) {
		&Error("No module name in $file.", "Specify the module name on the first line of config.conf like this: [MODNAME]", 1);
	}

  #use Data::Dumper; &Log(Dumper(\%conf)."\n", 1);
  return \%conf;
}

sub readSetCONF {

  # Perl variables from the [system] section of config.conf are only 
  # set by applyCONF_system() and they are NOT set by readSetCONF().

  our $CONF = &readConfFile($CONFFILE);
  if (!$CONF) {return 0;}
  
  my $mainmod = $CONF->{'MainmodName'};
  my $dictmod = $CONF->{'DictmodName'};
  
  # Config Defaults
  my $configRE = &configRE(@OC_CONFIGS);
  foreach my $e (@OC_CONFIGS, @SWORD_CONFIGS) {
    if (exists($CONFIG_DEFAULTS{$e})) {
      if (!exists($CONF->{"$mainmod+$e"})) {
        $CONF->{"$mainmod+$e"} = $CONFIG_DEFAULTS{$e};
      }
    }
    elsif ($e =~ /$configRE/ && $e !~ /^MATCHES\:/) {
      &ErrorBug("OC_CONFIGS $e should have a default value.");
    }
  }
  
  #use Data::Dumper; &Debug(Dumper($CONF)."\n");
  return 1;
}

# $CONF contains encoded data from the config.conf file. This function, 
# when used with only one argument, returns the proper value of a config 
# parameter, taking into account the context of $MOD and $SCRIPT_NAME. 
# Also, when passing explicit values for $mod and/or $script_name, the 
# config value for any other context can also be read. If $quiet is set
# return value checking is disabled.
sub conf {
  my $entry = shift;
  my $mod = shift;          #optional, context is $MOD
  my $script_name = shift;  #optional, context is $SCRIPT_NAME
  my $quiet = shift;
  
  $mod = ($mod ? $mod:$MOD);
  $script_name = ($script_name ? $script_name:$SCRIPT_NAME);
 
  my $key = '';
  my $isConf = &isValidConfig("$mod+$entry");
  if (!$isConf) {
    &ErrorBug("Unrecognized config request: $entry");
  }
  elsif ($isConf eq 'system') {
    &ErrorBug("Config request $entry is in the [system] section; use \$$entry rather than &conf('$entry') to access [system] section values.");
  }
  elsif (exists($CONF->{$script_name.'+'.$entry})) {
    $key = $script_name.'+'.$entry;
  }
  elsif ($CONF->{'DictmodName'} && $mod eq $CONF->{'DictmodName'} && exists($CONF->{$mod.'+'.$entry})) {
    $key = $mod.'+'.$entry;
  }
  elsif (exists($CONF->{$CONF->{'MainmodName'}.'+'.$entry})) {
    $key = $CONF->{'MainmodName'}.'+'.$entry;
  }
  
  #&Debug("entry=$entry, config-key=$key, value=".$CONF->{$key}."\n");
  
  if (!$quiet) {&isValidConfigValue($key, $CONF);}

  return ($key ? $CONF->{$key}:undef);
}

# Checks if the config entry name is valid (isValidConfigValue() checks
# the values).
# Returns 0 if $e is not a valid config entry.
# Returns 'sword-autogen' if it is a SWORD auto-generated entry.
# Returns 'sword' if it is an otherwise valid SWORD config.conf entry.
# Returns 'system' if it is a valid [system] config.conf entry.
# Returns 1 otherwise (valid, but nothing special).
sub isValidConfig {
  my $fullEntry = shift;
  
  if ($fullEntry =~ /^(MainmodName|DictmodName)$/) {
    return 1;
  }
  
  my $e = $fullEntry;
  my $s = ($e =~ s/^(.*?)\+// ? $1:'');
  if (!$s) {return 0;}
  
  # check for system entries (all of which may only appear in the system section)
  my $systemRE = &configRE(@OC_SYSTEM);
  if ($e =~ /$systemRE/) {
    if ($s ne 'system') {return 0;}
    return 'system';
  }
  if ($s eq 'system') {return 0;}

  # check for SWORD autogen
  my $swordAutoRE = &configRE(@SWORD_AUTOGEN);
  if ($e =~ /$swordAutoRE/) {return 'sword-autogen';}
  
  # check for other SWORD
  my $swordRE = &configRE(@SWORD_CONFIGS, @SWORD_OC_CONFIGS);
  if ($e =~ /$swordRE/) {return 'sword';}
  
  # check for other valid
  my $valid = &configRE(@OC_CONFIGS);
  if ($e =~ /$valid/) {return 1;}
  
  return 0;
}

sub isValidConfigValue {
  my $fullEntry = shift;
  my $confP = shift;
  
  my $e = $fullEntry; $e =~ s/^[^\+]+\+//;
  
  if ($e =~ /Title/ && $confP->{$fullEntry} =~ / DEF$/) {
    &Error("Using default value for $fullEntry: '".$confP->{$fullEntry}."'", 
    "Add $e=<localized-title> to the config.conf file.");
    return 0;
  }
  
  my $multRE = &configRE(@MULTIVALUE_CONFIGS);
  if ($confP->{$fullEntry} =~ /<nx\/>/ && $e !~ /$multRE/) {
    &Error("It is not allowed to have multiple '$e' entries in config.conf: ".$confP->{$fullEntry},
      "Remove all but one '$e' entries from config.conf.");
    return 0;
  }
  
  return 1;
}

# Builds a single regex from any number of entries of any of the global 
# config entry lists (such as @SWORD_CONFIGS) which can then be used to 
# match against any config entry to test for membership.
sub configRE {
  my @arr = @_;
  
  my @entryRE;
  foreach my $e (@arr) {
    # handle special case SWORD_LOCALIZABLE_CONFIGS
    my $a = '';
    foreach my $slc (@SWORD_LOCALIZABLE_CONFIGS) {
      if ($e eq $slc) {$a = '(_\w+)?';}
    }
    
    # remove MATCHES and treat the rest as regex
    $e =~ s/^MATCHES://;
    push(@entryRE, "$e$a");
  }
  
  return (@entryRE ? '^('.join('|', @entryRE).')$':'');
}

# Look for an osis-converters default file or directory in the following 
# places, in order. If a default file is not found, return either '' or 
# throw a stop error if priority was 0 (or null etc.). The file may  
# include a path that (presently) begins with either 'bible/' for Bible  
# module default files or 'dict/' for dictionary module default files,
# or 'childrens_bible/' for childrens' Bibles. The fallback for
# 'childrens_bible' calls is 'bible' if the former does not exist. 
# If priority 1, 2 or 3 is specified, only the location with that 
# priority will be checked:
# priority  location
#    1      Project directory (if bible|dict subdir matches the project type)
#    2      main-project-parent/defaults directory
#    3      osis-converters/defaults directory
#
# NOTE: priority -1 will check all locations in order but will not throw 
# an error upon failure to locate a file.
#
# NOTE: Soft links in the file path are followed, but soft links that 
# are valid on the host will NOT be valid on a VM! To work for the VM, 
# soft links must be valid from the VM's perspective (so they will begin 
# with /vagrant and will be broken on the host, but will work on the VM).
sub getDefaultFile {
  my $file = shift;
  my $priority = shift;
  my $maininpd = shift; $maininpd = ($maininpd ? $maininpd:$MAININPD);
  
  my $mainmod = $maininpd; $mainmod =~ s/^.*?\/([^\/]+)\/?$/$1/;
  
  my $moduleFile = $file;
  my $fileType = ($moduleFile =~ s/^(childrens_bible|bible|dict)\/// ? $1:'');
  
  my $defaultFile;
  my $checkAll = ($priority != 1 && $priority != 2 && $priority != 3);
  
  my $projectDefaultFile = ($fileType eq 'dict' ? "$maininpd/${mainmod}DICT":$maininpd).'/'.$moduleFile;
  my $mainParent = "$maininpd/..";
  if (($checkAll || $priority == 1) && -e $projectDefaultFile) {
    $defaultFile = $projectDefaultFile;
    &Note("getDefaultFile: (1) Found $file at $defaultFile");
  }
  if (($checkAll || $priority == 2) && -e "$mainParent/defaults/$file") {
    if (!$defaultFile) {
      $defaultFile = "$mainParent/defaults/$file";
      &Note("getDefaultFile: (2) Found $file at $defaultFile");
    }
    elsif ($^O =~ /linux/i && !&shell("diff '$mainParent/defaults/$file' '$defaultFile'", 3)) {
      &Note("(2) Default file $defaultFile is not needed because it is identical to the more general default file at $mainParent/defaults/$file");
    }
  }
  if (($checkAll || $priority == 3) && -e "$SCRD/defaults/$file") {
    if (!$defaultFile) {
      $defaultFile = "$SCRD/defaults/$file";
      &Note("getDefaultFile: (3) Found $file at $defaultFile");
    }
    elsif ($^O =~ /linux/i && !&shell("diff '$SCRD/defaults/$file' '$defaultFile'", 3)) {
      &Note("(3) Default file $defaultFile is not needed because it is identical to the more general default file at $SCRD/defaults/$file");
    }
  }
  if ($fileType eq 'childrens_bible' && !$defaultFile) {return &getDefaultFile("bible/$moduleFile", $priority);}
  if (!$priority && !$defaultFile) {
    &ErrorBug("Default file $file could not be found in any default path; add this file to the osis-converters/defaults directory.", 1);
  }
  return $defaultFile;
}

# Return 1 if dependencies are met for $script and 0 if not
sub checkDependencies {
  my $script = shift;
  my $scrd = shift;
  my $inpd = shift;
  my $quiet = shift;
  
  my $logflag = ($quiet ? ($DEBUG ? 2:3):1);

  my @deps;
  if ($script =~ /(sfm2all)/) {
    @deps = ('SWORD_PERL', 'SWORD_BIN', 'XMLLINT', 'GO_BIBLE_CREATOR', 'MODULETOOLS_BIN', 'XSLT2', 'CALIBRE');
  }
  elsif ($script =~ /(update)/) {
    @deps = ('SWORD_PERL', 'XMLLINT', 'MODULETOOLS_BIN', 'XSLT2');
  }
  elsif ($script =~ /(sfm2osis|osis2osis)/) {
    @deps = ('SWORD_PERL', 'XMLLINT', 'MODULETOOLS_BIN', 'XSLT2');
  }
  elsif ($script =~ /osis2sword/) {
    @deps = ('SWORD_PERL', 'SWORD_BIN', 'MODULETOOLS_BIN', 'XSLT2');
  }
  elsif ($script =~ /osis2ebooks/) {
    @deps = ('SWORD_PERL', 'MODULETOOLS_BIN', 'XSLT2', 'CALIBRE');
  }
  elsif ($script =~ /osis2html/) {
    @deps = ('SWORD_PERL', 'MODULETOOLS_BIN', 'XSLT2');
  }
  elsif ($script =~ /osis2GoBible/) {
    @deps = ('SWORD_PERL', 'GO_BIBLE_CREATOR', 'MODULETOOLS_BIN', 'XSLT2');
  }
  
  # XSLT2 also requires that openjdk 10.0.1 is NOT being used 
  # because its Unicode character classes fail with saxonb-xslt.
  my %depsh = map { $_ => 1 } @deps;
  if ($depsh{'XSLT2'}) {push(@deps, 'JAVA');}
  
  my %test;
  $test{'SWORD_BIN'}        = [ &escfile($SWORD_BIN."osis2mod"), "You are running osis2mod: \$Rev: 3431 \$" ]; # want specific version
  $test{'XMLLINT'}          = [ "xmllint --version", "xmllint: using libxml" ]; # who cares what version
  $test{'GO_BIBLE_CREATOR'} = [ "java -jar ".&escfile($GO_BIBLE_CREATOR."GoBibleCreator.jar"), "Usage" ];
  $test{'MODULETOOLS_BIN'}  = [ &escfile($MODULETOOLS_BIN."usfm2osis.py"), "Revision: 491" ]; # check version
  $test{'XSLT2'}            = [ 'saxonb-xslt', "Saxon 9" ]; # check major version
  $test{'JAVA'}             = [ 'java -version', "openjdk version \"10.", 1 ]; # NOT openjdk 10.
  $test{'CALIBRE'}          = [ "ebook-convert --version", "calibre 3" ]; # check major version
  $test{'SWORD_PERL'}       = [ "perl -le 'use Sword; print \$Sword::SWORD_VERSION_STR'", "1.8.900" ]; # check version
  
  my $fail;
  foreach my $p (@deps) {
    if (!exists($test{$p})) {
      &ErrorBug("No test for \"$p\".");
      return 0;
    }
    system($test{$p}[0]." >".&escfile("tmp.txt"). " 2>&1");
    if (!open(TEST, $READLAYER, "tmp.txt")) {
      &ErrorBug("Could not read test output file \"$SCRD/tmp.txt\".");
      return 0;
    }
    my $result; {local $/; $result = <TEST>;} close(TEST); unlink("tmp.txt");
    my $need = $test{$p}[1];
    if (!$test{$p}[2] && $result !~ /\Q$need\E/im) {
      &Error("Dependency $p failed:\n\tRan: \"".$test{$p}[0]."\"\n\tLooking for: \"$need\"\n\tGot:\n$result\n");
      $fail++;
    }
    elsif ($test{$p}[2] && $result =~ /\Q$need\E/im) {
      &Error("Dependency $p failed:\n\tRan: \"".$test{$p}[0]."\"\n\tCannot have: \"$need\"\n\tGot:\n$result\n");
      $fail++;
    }
    #&Note("Dependency $p:\n\tRan: \"".$test{$p}[0]."\"\n\tGot:\n$result");
  }
  
  if ($fail) {
    if (!&runningInVagrant()) {
      &Log("
      SOLUTION: On Linux systems you can try installing dependencies by running:
      $scrd/provision.sh\n\n", 1);
    }
    return 0;
  }
  
  return 1;
}


########################################################################
# Vagrant related functions
########################################################################

# The host share directory cannot be just a Windows drive letter (native 
# or emulated) because Vagrant cannot create a share to the root of a 
# window's drive.
sub vagrantHostShare {

  if ($INPD !~ /^((?:\w\:|\/\w)?\/[^\/]+)/) {
    die "Error: Cannot parse project path \"$INPD\"\n";
  }
  return $1;
}

sub vagrantInstalled {

  print "\n";
  my $pass;
  system("vagrant -v >tmp.txt 2>&1");
  if (!open(TEST, $READLAYER, "tmp.txt")) {die;}
  $pass = 0; while (<TEST>) {if ($_ =~ /\Qvagrant\E/i) {$pass = 1; last;}}
  unlink("tmp.txt");

  return $pass;
}

sub restart_with_vagrant {

  if (!-e "$SCRD/Vagrantcustom" && open(VAGC, $WRITELAYER, "$SCRD/Vagrantcustom")) {
    print VAGC "# NOTE: You must halt your VM for changes to take effect\n
  config.vm.provider \"virtualbox\" do |vb|
    # Set the RAM for your Vagrant VM
    vb.memory = 2560
  end\n";
    close(VAGC);
  }
  
  chdir $SCRD; # Required for the following vagrant commands to work

  # Make sure Vagrant is up, and with the right share(s)
  my @shares;
  push(@shares, &vagrantShare(&vagrantHostShare(), "$VAGRANT_HOME/INDIR_ROOT"));
  my $status = (-e "./.vagrant" ? &shell("vagrant status", 3):'');
  if ($status !~ /\Qrunning (virtualbox)\E/i) {
    &vagrantUp(\@shares);
  }
  elsif (!&matchingShares(\@shares)) {
    &shell("vagrant halt", 3);
    &vagrantUp(\@shares);
  }

  my $scriptRel = "/vagrant/".File::Spec->abs2rel($SCRIPT, $SCRD); $scriptRel =~ s/\\/\//g;
  my $inpdRel = File::Spec->abs2rel($INPD, &vagrantHostShare()); $inpdRel =~ s/\\/\//g;
  my $cmd = "vagrant ssh -c \"'$scriptRel' '$VAGRANT_HOME/INDIR_ROOT/$inpdRel'\"";
  print "\nStarting Vagrant with...\n$cmd\n";
  
  # Continue printing to console while Vagrant ssh remains open
  open(VUP, "$cmd |");
  while(<VUP>) {print $_;}
  close(VUP);
}

sub runningInVagrant {

  return (-e "/vagrant/Vagrantfile" ? 1:0);
}

sub vagrantShare {
  my $host = shift;
  my $client = shift;

  # If the host is Windows, $host must be a native path!
  $host =~ s/^((\w)\:|\/(\w))\//uc($+).":\/"/e;
  $host =~ s/\\/\\\\/g; $client =~ s/\\/\\\\/g; # escape "\"s for use as Vagrantfile quoted strings
  return "config.vm.synced_folder \"$host\", \"$client\"";
}

sub vagrantUp {
  my $sharesP = shift; # \@
  
  if (!-e "./.vagrant") {mkdir("./.vagrant");}
  
  # Create input/output filesystem shares
  open(VAG, $WRITELAYER, "./Vagrantshares") || die "\nError: Cannot open \"./Vagrantshares\"\n";
  foreach my $share (@$sharesP) {print VAG "$share\n";}
  close(VAG);
  print "
Starting Vagrant...
The first use of Vagrant will automatically download and build a virtual
machine having osis-converters fully installed. This build will take some
time. Subsequent use of Vagrant will run much faster.\n\n";
  open(VUP, "vagrant up |");
  while(<VUP>) {print $_;}
  close(VUP);
}

# returns 1 if all shares match, 0 otherwise
sub matchingShares {
  my $sharesP = shift; # \@
  
  my %shares; foreach my $sh (@$sharesP) {$shares{$sh}++;}
  open(CSH, $READLAYER, "./Vagrantshares") || return 0;
  while(<CSH>) {
    if ($_ =~ /^(\Qconfig.vm.synced_folder\E\s.*)$/) {$shares{$1}++;}
    foreach my $share (@$sharesP) {if ($_ =~ /^\Q$share\E$/) {delete($shares{$share});}}
  }
  return (keys(%shares) == 0 ? 1:0);
}


########################################################################
# Logging functions
########################################################################

# Report errors that users need to fix
my %ERR_CHECK;
sub Error {
  my $errmsg = shift;
  my $solmsg = shift;
  my $doDie = shift;
  
  # Solution msgs beginning with <> will only be output once
  if ($solmsg =~ s/^<>//) {
    if ($ERR_CHECK{$solmsg}) {$solmsg='';} 
    else {$ERR_CHECK{$solmsg}++;}
  }
  
  # Terms beginning with <- will not have a leading line-break
  my $n1 = ($errmsg =~ s/^<\-// ? '':"\n");

  &Log($n1."ERROR: $errmsg\n", 1);
  if ($solmsg) {&Log("SOLUTION: $solmsg\n", 1);}
  
  if ($doDie) {&Log("Exiting...\n", 1); exit;}
}

# Report errors that are unexpected or need to be seen by osis-converters maintainer
sub ErrorBug {
  my $errmsg = shift;
  my $doDie = shift;
  
  &Log("\nERROR (UNEXPECTED): $errmsg\n", 1);
  
  use Carp qw(longmess);
  &Log(&longmess());
  
  &Log("Report the above unexpected error to osis-converters maintainer.\n\n");
  
  if ($doDie) {&Log("Exiting...\n", 1); exit;}
}

my (%WARN_MSG, %WARN_CHECK);
sub Warn {
  my $warnmsg = shift;
  my $checkmsg = shift;
  my $flag = shift;
  
  # Terms beginning with <- will not have a leading line-break
  my $n1 = ($warnmsg =~ s/^<\-// ? '':"\n");
  my $n2 = ($checkmsg =~ s/^<\-// ? '':"\n");
  
  # If either term begins with -> there will be no ending line-break
  my $endbreak = ($warnmsg =~ s/^\->// ? '':"\n");
  $endbreak = ($checkmsg =~ s/^\->// || !$endbreak ? '':"\n");
  
  # Messages beginning with <> will only be output once
  if ($warnmsg  =~ s/^<>//) {if ($WARN_MSG{$warnmsg})    {$warnmsg='';}  else {$WARN_MSG{$warnmsg}++;}}
  if ($checkmsg =~ s/^<>//) {if ($WARN_CHECK{$checkmsg}) {$checkmsg='';} else {$WARN_CHECK{$checkmsg}++;}}

  if ($warnmsg) {
    &Log($n1."WARNING: $warnmsg", $flag);
  }
  if ($checkmsg) {
    &Log($n2."CHECK: $checkmsg", $flag);
  }
  if ($endbreak && ($warnmsg || $checkmsg)) {&Log("\n");}
}

my %NOTE_MSG;
sub Note {
  my $notemsg = shift;
  my $flag = shift;
  
  # If message begins with -> there will be no ending line-break
  my $endbreak = ($notemsg =~ s/^\->// ? '':"\n");
  
  # Messages beginning with <> will only be output once
  if ($notemsg  =~ s/^<>//) {if ($NOTE_MSG{$notemsg}) {$notemsg='';} else {$NOTE_MSG{$notemsg}++;}}
  if (!$notemsg) {return;}
  
  &Log("NOTE: $notemsg$endbreak", $flag);
}

sub Debug {
  my $dbgmsg = shift;
  my $flag = shift;
  
  if ($DEBUG) {&Log("DEBUG: $dbgmsg", ($flag ? $flag:1));}
}

sub Report {
  my $rptmsg = shift;
  my $flag = shift;
  
  # Terms beginning with <- will not have a leading line-break
  my $n1 = ($rptmsg =~ s/^<\-// ? '':"\n");
  
  &Log("$n1$MOD REPORT: $rptmsg\n", $flag);
}

# Log to console and logfile. $flag can have these values:
# -1   = only log file
#  0,1 = log file + console
#  2   = only console
#  3   = don't log anything
my $LOGFILE_BUFFER;
sub Log {
  my $p = shift; # log message
  my $flag = shift;
  
  if ($flag == 3) {return;}
  
  $p =~ s/&lt;/</g; $p =~ s/&gt;/>/g; $p =~ s/&amp;/&/g;
  $p =~ s/&#(\d+);/my $r = chr($1);/eg;
  
  if ($p =~ /ERROR/) {
    my $ne = &conf('ARG_noErr');
    if ($ne && $p =~ /$ne/) {$p =~ s/ERROR/WARNING/g;}
  }
  elsif ($p =~ /^[\n\s]*WARNING\:/) {
    my $nw = &conf('ARG_noWarning');
    if ($nw && $p =~ /$nw/) {return;}
  }
  
  if ($flag >= 1 || $p =~ /(ERROR|DEBUG)/ || $LOGFILE eq 'none') {
    print encode("utf8", $p);
  }
  
  if ($flag == 2 || $LOGFILE eq 'none') {return;}
  
  if ($p !~ /ERROR/ && !$DEBUG) {$p = &encodePrintPaths($p);}
  
  if (!$LOGFILE) {$LOGFILE_BUFFER .= $p; return;}

  open(LOGF, $APPENDLAYER, $LOGFILE) || die "Could not open log file \"$LOGFILE\"\n";
  if ($LOGFILE_BUFFER) {print LOGF $LOGFILE_BUFFER; $LOGFILE_BUFFER = '';}
  print LOGF $p;
  close(LOGF);
}

my $LOCAL;
sub encodePrintPaths {
  my $t = shift;
  
  no strict "refs";
  
  # $LOCAL needs to be a global, but it cannot be changed by config.conf
  if ($^O =~ /linux/i) {$LOCAL = &expandLinuxPath('~/.osis-converters'); }
  
  # encode these local file paths, from longest to shortest
  my @paths = ('SCRD', 'MAININPD', 'MOD_OUTDIR', 'LOCAL', 'SWORD_BIN', 'XMLLINT', 'MODULETOOLS_BIN', 'XSLT2', 'GO_BIBLE_CREATOR', 'CALIBRE');
  foreach my $path (sort { length $$b <=> length $$a } @paths) {
    if (!$$path) {next;}
    my $rp = $$path;
    $rp =~ s/[\/\\]+$//;
    $t =~ s/\Q$rp\E/\$$path/g;
  }
  
  # since log files are written to MOD_OUTDIR, simplify this further
  $t =~ s/\$MOD_OUTDIR\//.\//g;

  return $t;
}


########################################################################
# Utility functions
########################################################################

sub expandLinuxPath {
  my $path = shift;

  if ($^O !~ /linux/i) {&ErrorBug("expandLinuxPath() should only be run on Linux, but opsys is: $^O", 1);}
  my $r = &shell("echo $path", 3);
  chomp($r);
  return $r;
}

sub shortLinuxPath {
  my $path = shift;

  $path =~ s%/\./%/%g;
  $path =~ s%/[^/]+/\.\.(/|$)%$1%g;
  return $path;
}

sub escfile {
  my $n = shift;
  
  $n =~ s/([ \(\)])/\\$1/g;
  return $n;
}

sub isFolderEmpty { 
  my $dirname = shift;

  opendir(my $dh, $dirname) or die "Not a directory"; 
  return scalar(grep { $_ ne "." && $_ ne ".." } readdir($dh)) == 0;
}

sub printInt {
  my $in = shift; # a number

  my $b = int(0.5 + $in); # rounded to nearest int
  while($b =~ s/(\d+)(\d\d\d)/$1\,$2/){};
  return $b; # rounded with commas: 45,567,234
}

# Run a Linux shell script. $flag can have these values:
# -1   = only log file
#  0,1 = log file + console
#  2   = only console
#  3   = don't log anything
sub shell {
  my $cmd = shift;
  my $flag = shift; # same as Log flag
  
  &Log("\n$cmd\n", $flag);
  my $result = decode('utf8', `$cmd 2>&1`);
  &Log($result."\n", $flag);
  
  return $result;
}

sub urlencode {
  my $s = shift;
  $s =~ s/([\Q "<>`#?{}\E])/sprintf("%%%02X", ord($1))/seg;
  return $s;
}

1;
