#!/usr/bin/perl
# This file is part of "osis-converters".
# 
# Copyright 2021 John Austin (gpl.programs.info@gmail.com)
#     
# "osis-converters" is free software: you can redistribute it and/or 
# modify it under the terms of the GNU General Public License as 
# published by the Free Software Foundation, either version 2 of 
# the License, or (at your option) any later version.
# 
# "osis-converters" is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with "osis-converters".  If not, see 
# <http://www.gnu.org/licenses/>.

# This script might be run on Linux, MS-Windows, or MacOS operating systems.

our ($SCRIPT_NAME, @CONV_OSIS, @CONV_PUBS);

# Argument globals
our ($HELP, $INPD, $LOGFILE, $NO_ADDITIONAL, $CONVERSION, $MODRE, $MAXTHREADS, $SKIPRE);

# Each script takes 3 types of arguments: 'switch', 'option' and 'argument'.
# Each argument is specified by: [ <global-name>, <default-value>, <short-description>, <documentation> ]
our %ARG = (

  'all' => { # Arguments available to all scripts:
  
    'switch' => {
    
      'h' => [ 'HELP', 0, 'boolean', 'Show usage message and exit.' ],
    },
    
    'argument' => {
    
      'first' => [ 'INPD', '.', 'dir', 'Path to an osis-converters project directory. Default is the working directory.' ],
    
      'second' => [ 'LOGFILE', undef, 'log', 'Log file path. Default is OUT_<script>.txt in the project\'s output directory.' ],
    },
  },

  'convert' => { # Arguments available to the 'convert' script:
  
    'switch' => {
    
      'n' => [ 'NO_ADDITIONAL', 0, 'boolean', 'No additional modules will be run to meet any dependencies.' ], 
    },
    
    'argument' => {
    
      # this overrides the second argument of 'all' above
      'second' => [ 'LOGFILE', './OUT_convert.txt', 'log', 'Log file path. Default is ./OUT_convert.txt in the working directory.' ],
    },
    
    'option' => {
      
      'c' => [ 'CONVERSION', 'sfm2all', 'conv', 'Conversion(s) to run. Default is "sfm2all". Others are: ' . join(', ', sort keys %{&listConversions(\@CONV_OSIS, \@CONV_PUBS)}) . '.' ],
      
      'm' => [ 'MODRE', '.+', 'rx', 'Regex matching modules to run. Default is all.' ],

      't' => [ 'MAXTHREADS', &numCPUs(), 'N', 'Number of threads to use. Default is '.&numCPUs() . '.' ],

      'x' => [ 'SKIPRE', undef, 'rx', 'Regex matching modules to skip. Default is none.' ],
    },
  },
);

# osis-converters help documentation is stored in the following data structure:
# <script> => [ [ <heading>, [ [ sub-heading|para|list, value ], ... ] ], ... ]
# where: list = [ 'list', [key-heading, description-heading], [ [ <name>, <description> ], ... ] ]

# Scope help??
our %HELP = (

'sfm2osis' => [

  ['CONVERT PARATEXT FILES INTO OSIS XML', [
    ['para', 'OSIS is an xml standard for encoding Bibles and related texts (see: http://crosswire.org/osis/). The OSIS files generated by sfm2osis will include meta-data, explicit references, and textual information not present in the original Paratext Universal Standard Format Marker (USFM) source texts. The resulting OSIS file is thus a more complete source text than the original Paratext files. As an XML standard, the OSIS file is an excellent intermediate source text which is easily and reliably converted into any other format.' ],
    ['para',  'The conversion process is directed by control files. A description of each control file and its options follows. Default control files are created by the \'defaults\' command.' ],
  ]],
  
  ['config.conf', [
    ['para', ' Each project has a config.conf file located in its top directory. The configuration file contains conversion settings and meta-data for the project. A project consist of a single main module, and possibly a single dictionary module containing reference material. A config.conf file usually has multiple sections. The main section contains configuration settings applying to the entire project, while settings of other sections are effective in a particular context, overriding any matching settings found in the main section. The \'system\' section is special because it contains global constants that are the same in any context. The following sections are recognized: '.join(', ', map("'$_'", @CONFIG_SECTIONS)). ' (MAINMOD is the project code and DICTMOD is the same project code suffixed with \'DICT\'). What follows are all settings available in the config.conf file. The letters in parenthesis indicate the following special features:'],
    ['list', ['' ,''], 
    [
      ['(C)', 'These entry values are continuable from one line to the next using a backslash character.'],
      ['(L)', 'These entry values are localizable by appending an underscore and language ISO code to the entry name.'],
      ['(S)', 'These entries may only appear in the system section.'],
      ['(W)', 'These entries are also SWORD standard entries (see https://wiki.crosswire.org/DevTools:conf_Files).'],
    ]],
    ['list', ['ENTRY', 'DESCRIPTION'], 
      &addEntryType(&getList([&{sub {$re=&configRE(@SWORD_AUTOGEN_CONFIGS); return grep {$_ !~ /$re/} @_;}}(@SWORD_CONFIGS, @SWORD_OC_CONFIGS, @OC_CONFIGS)], 
    [
      [ 'Abbreviation', 'A short localized name for the module.' ],
      [ 'About', 'Localized information about the module.' ],
      [ 'Description', 'A short localized description of the module.' ],
      [ 'KeySort', 'This entry allows sorting a language in any desired way using character collation. Square brackets are used to separate any arbitrary JDK 1.4 case sensitive regular expressions which are to be treated as single characters during the sort comparison. Also, a single set of curly brackets can be used around a regular expression which matches any characters/patterns that need to be ignored during the sort comparison. IMPORTANT: Any square or curly bracket within these regular expressions must have an ADDITIONAL \ before it.' ],
      [ 'LangSortOrder', 'DEPRECATED. Use the more flexible KeySort instead.' ],
      [ 'AudioCode', 'A publication code for associated audio. Multiple modules having different scripts may reference the same audio.' ],
      [ 'AddScripRefLinks', 'Select whether to parse scripture references in the text and convert them to hyperlinks: (true|false|AUTO).' ],
      [ 'AddDictLinks' => 'Select whether to parse glossary references in Bible text and convert them to hyperlinks: (true|false|check|AUTO).' ],
      [ 'AddSeeAlsoLinks' => 'Select whether to parse glossary references in glossary text and convert them to hyperlinks: (true|false|check|AUTO).' ],
      [ 'AddFootnoteLinks' => 'Select whether to parse footnote references in the text and convert them to hyperlinks: (true|false|AUTO).' ],
      [ 'AddCrossRefLinks' => 'Select whether to insert externally generated cross-reference notes into the text: (true|false|AUTO).' ],
      [ 'Versification' => 'The versification system of the project. All deviations from this verse system must be recorded in CF_sfm2osis.txt by VSYS instructions. Supported options are: '.join(', ', split(/\|/, $SWORD_VERSE_SYSTEMS)).'.' ],
      [ 'Encoding' => 'osis-converters only supports UTF-8 encoding.' ],
      [ 'TOC' => 'A number from 1 to 3 indicating which SFM tags to use for generating the Table Of Contents: \toc1, \toc2 or \toc3.' ],
      [ 'TitleCase' => 'A number from 0 to 2 selecting letter casing for the Table Of Contents: 0 is as-is, 1 is Like This, 2 is LIKE THIS.' ],
      [ 'TitleTOC' => 'A number from 1 to 3 indicating which SFM tags to use for generating the publication titles: \toc1, \toc2 or \toc3.' ],
      [ 'CreatePubTran' => 'Select whether to create a single ePublication containing everything in the OSIS file: (true|false|AUTO).'],
      [ 'CreatePubSubpub' => 'Select whether to create separate outputs for individual sub-publications within the OSIS file: (true|false|AUTO|<scope>|first|last).' ],
      [ 'CreatePubBook' => 'Select whether to create separate ePublications for individual Bible books within the OSIS file: (true|false|AUTO|<OSIS-book>|first|last).' ],
      [ 'CreateTypes' => 'Select which type, or types, of eBooks to create: (AUTO|epub|azw3|fb2).' ],
      [ 'CombineGlossaries' => 'Set this to \'true\' to combine all glossaries into one, or false to keep them each as a separate glossary. \'AUTO\' let\'s osis-converters decide.' ],
      [ 'FullResourceURL' => 'Single Bible book eBooks often have links to other books. This URL is where the full publication may be found.' ],
      [ 'CustomBookOrder' => 'Set to true to allow Bible book order to remain as it appears in CF_sfm2osis.txt, rather than project versification order: (true|false).' ],
      [ 'ReorderGlossaryEntries' => 'Set to true and all glossaries will have their entries re-ordered according to KeySort, or else set to a regex to re-order only glossaries whose titles match: (true|<regex>).' ],
      [ 'CombinedGlossaryTitle' => 'A localized title for the combined glossary in the Table of Contents.' ],
      [ 'BookGroupTitle\w+' => 'A localized title to use for these book groups: '.&{sub {my $x=join(', ', @OSIS_GROUPS); $x=~s/_/ /g; return $x;}}().'.' ],
      [ 'BookGroupTitleOT' => 'A localized title for the New Testament in the Table of Contents.' ],
      [ 'BookGroupTitleNT' => 'A localized title for the Old Testament in the Table of Contents.' ],
      [ 'TranslationTitle' => 'A localized title for the entire translation.' ],
      [ 'IntroductionTitle' => 'A localized title for Bible book introductions.' ],
      [ 'TitleSubPublication\[\S+\]', 'A localized title for each sub-publication. A sub-publication is created when SFM files are placed within an sfm subdirectory. The name of the sub-directory must be the scope of the sub-publication (with spaces replaced by underscores).' ], 
      [ 'NormalizeUnicode' => 'Apply a Unicode normalization to all characters: (true|false|NFD|NFC|NFKD|NFKC|FCD).' ],
      [ 'Lang' => 'ISO language code and script code. Examples: tkm-Cyrl or tkm-Latn' ],
      [ 'ARG_\w+' => 'Config settings for undocumented fine control.' ],
      [ 'GlossaryNavmenuLink\[[1-9]\]' => 'Specify custom DICTMOD module navigation links.' ], 
      [ 'History_[\d\.]+' => 'Each version of released publications should have one of these entries describing what is new that version.' ],              
      [ 'Version', 'The version of the publication being produced.' ],
    ]))],
  ]],
  
  ['CF_sfm2osis.txt', [
  
  ]],
  
  ['CF_addScripRefLinks.txt', [
  
  ]],
  
  ['CF_addFootnoteLinks.txt', [
  
  ]],
  
  [$DICTIONARY_WORDS, [
  
  ]],
],

'osis2osis' => [

  ['Overview', [
    ['para', 'This is the Overview text.'],
  ]],
  
  ['CF_osis2osis.txt', [
    ['para', 'This is the CF_osis2osis.txt text.'],
  ]],
],
);

# Search for a particular key in a %HELP list and return its value. Key
# can be a script name, a heading, or the entry part of any 'list'.
sub help {
  my $lookup = shift;
  
  if (ref($HELP{$lookup})) {return &helpTop($HELP{$lookup});}
  
  my $r;
  foreach my $script (sort keys %HELP) {
    foreach my $headP (@{$HELP{$script}}) {
      if ($headP->[0] =~ /\Q$lookup\E/i) {
        return &helpHeading($headP->[1]);
      }
      foreach my $subP (@{$headP->[1]}) {
        if ($subP->[0] ne 'list') {next;}
        foreach my $listP (@{$subP->[1]}) {
          if ($listP->[0] =~ /\Q$lookup\E/i) {
            return $listP->[1];
          }
        }
      }
    }
  }
  
  return "No help available for $script.";
}

sub helpTop {
  my $topAP = shift;
  
  my $r; foreach (@{$topAP}) {$r .= &helpHeading($_);}
  
  return $r;
}

sub helpHeading {
  my $headingAP = shift;
  
  my $r = &format($headingAP->[0], 'heading');
    
  foreach my $s (@{$headingAP->[1]}) {
    if ($s->[0] eq 'list') {
      $r .= &helpList($s->[1], $s->[2]);
    }
    else {
      $r .= &format($s->[1], $s->[0]);
    }
  }
  
  return $r;
}

sub format {
  my $text = shift;
  my $type = shift;
  my $listAP = shift;
  
  my @args; if ($type =~ s/:(.+)$//) {@args = split(/,/, $1);}
  
  if ($type eq 'heading') {
    return $text . "\n" . '-' x length($text) . "\n";
  }
  elsif ($type eq 'sub-heading') {
    return uc($text) . "\n";
  }
  elsif ($type eq 'para') {
    return &para($text, @args);
  }
  
  return $text;
}

sub helpList {
  my $listheadAP = shift;
  my $listAP = shift;
  
  my $sep = ' -';
 
  # find column 1 width
  my $left = 0;
  foreach my $row (@{$listAP}) {
    if ($left < length($row->[0])) {$left = length($row->[0]);}
  }
  
  my $r = &listRow( $listheadAP->[0], 
                    $listheadAP->[1], 
                    $left, 
                    ' ' x length($sep));
                    
  foreach my $row (@{$listAP}) {
    $r .= &listRow($row->[0], $row->[1], $left, $sep) . "\n";
  }
  
  return $r;
}

sub listRow {
  my $key = shift;
  my $description = shift;
  my $left = shift;
  my $sep = shift;
  
  if (!$key && !$description) {return '';}
  
  if ($left > 28) {$left = 28;}

  return sprintf("%-${left}s%s%s", 
    $key,
    ($description ? $sep : ''),
    &para( $description, -1, $left + length($sep), undef, 1 ));
}

# Return a formatted paragraph of string t. Whitespace is first norm-
# alized in the string. $indent is the first line indent, $left is the
# left margin, and $width is the width in characters of the paragraph.
# $indent of -1 means output starts with the first character of $t (or
# -$left in other words).
sub para {
  my $t = shift;
  my $indent = shift; if (!defined($indent)) {$indent = 0;}
  my $left   = shift; if (!defined($left))   {$left   = 0;}
  my $width  = shift; if (!defined($width))  {$width  = 72;}
  my $noBlankLine = shift;
  
  $t =~ s/\s*\n\s*/ /g;
  $t =~ s/(^\s*|\s*$)//g;
  
  if ($indent == -1) {
    $indent = 0;
  }
  else {
    $indent = $left + $indent;
  }
  if ($indent) {$t = ' ' x $indent . $t;}
  
  my $tab = ' ' x $left;
 
  my $w = $width - $left - 12;
  
  my $out;
  my $i = $w + $indent;
  while ($t =~ s/^(.{$i}\S*\s+)//) {
    $out .= "$1\n$tab";
    $i = $w
  }
  $out .= $t . "\n" . (!$noBlankLine ? "\n" : '');
  
  return $out;
}

# Return a pointer to an array of help-list rows. Each key in $keyAP 
# becomes the key of a new row in the help-list, while the description 
# is a combination of any matching key description found in $descAP and 
# any matching default value in %CONFIG_DEFAULTS. Any unused 
# descriptions in $descAP will generate an error.
sub getList {
  my $keyAP = shift;
  my $descAP = shift;
  
  my $refRE = &configRE(keys %CONFIG_DEFAULTS);
  
  my @out;
  # Go through all required keys (some may be MATCHES keys)
  foreach my $k (sort @{$keyAP}) {
    my $key = $k;
    
    # Look for one or more matching description keys
    my @desc;
    if ($key =~ s/^MATCHES://) {
      foreach my $kdP (@{$descAP}) {
        if ($kdP->[0] =~ /^($key)$/ || $kdP->[0] eq $key) {
          push(@desc, $kdP->[0]);
        }
      }
    }
    else {push(@desc, $key);}
    
    # Output one row for each matching description
    foreach my $k2 (sort @desc) {
    
      my $descP; foreach my $kdP (@{$descAP}) {
        if ($kdP->[0] eq $k2) {$descP = $kdP; $kdP = undef;}
      }
      
      my $def;
      if ($key =~ /($refRE)/) {$def = $CONFIG_DEFAULTS{$key};}
      if ($def =~ /DEF$/) {$def = '';}
      
      push(@out, [
        ($descP->[0] ? $descP->[0] : $key), 
        ($descP->[1] ? $descP->[1].' ':'').($def ? "Default is '$def'.":'')
      ]);
    }
  }
  
  foreach (@{$descAP}) {
    if (ref($_) && ($_->[0] || $_->[1])) {
      &ErrorBug("Unused description: '".$_->[0]."', '".$_->[1]."'\n", 1);
    }
  }

  return \@out;
}

# Adds an entry type code to each key of a 'list'.
sub addEntryType {
  my $aP = shift;

  my %re = (
    'system' => ['S', &configRE(@OC_SYSTEM_CONFIGS)],
    'local'  => ['L', &configRE(@SWORD_LOCALIZABLE_CONFIGS, @OC_LOCALIZABLE_CONFIGS)],
    'cont'   => ['C', &configRE(@CONTINUABLE_CONFIGS)],
    'sword'  => ['W', &configRE(@SWORD_CONFIGS)],
  );
  
  foreach my $rP (@{$aP}) {
    my @types;
    foreach my $t (sort keys %re) {
      my $a = $re{$t}[1];
      if ($rP->[0] =~ /$a/) {push(@types, $re{$t}[0]);}
    }
    if (@types) {
      $rP->[0] .= ' ('.join('', @types).')';
    }
  }
  
  return $aP;
}

sub usage {
  my $r = "\nUSAGE: $SCRIPT_NAME ";
    
  my %p; my $c;
  foreach my $t ('argument', 'option', 'switch') {
    foreach my $s ('all', $SCRIPT_NAME) {
      foreach my $a (sort keys %{$ARG{$s}{$t}}) {
        if ( $s eq 'all' && exists($ARG{$SCRIPT_NAME}{$t}{$a}) ) {
          next;
        }
        my @a = @{$ARG{$s}{$t}{$a}};
        
        my $sub = ( $t eq 'switch' ? "-$a" : 
                  ( $t eq 'option' ? "-$a ".@a[2] : @a[2] ));
               
        # Set the sort order using numbered hash keys
        my $k1 = ($t eq 'switch'   ? 100 : ($t eq 'option' ? 1000: 10000));
        my $k2 = ($t eq 'argument' ? 100 : ($t eq 'switch' ? 1000: 10000));
        
        $p{'tem'}{ ($k1 + $c) } = "[$sub]";
        $p{'exp'}{ ($k2 + $c) }{$sub} = @a[3];
        $c++;
      }
    }
  }
  
  my $l = 0; foreach (keys %{$p{'tem'}}) {
    if ($l < length($p{'tem'}{$_})-2) {$l = length($p{'tem'}{$_})-2;}
  }
  
  my $tem = 
    join(' ', map($p{'tem'}{$_}, sort {$a <=> $b} keys %{$p{'tem'}}));
    
  my $exp;
  foreach my $i (sort {$a <=> $b} keys %{$p{'exp'}}) {
    foreach my $s (sort keys %{$p{'exp'}{$i}}) {
      $exp .= sprintf('%-'.$l."s : %s\n", 
              $s, &usagePrint(($l+3), 72, $p{'exp'}{$i}{$s}));
    }
  }
  
  $r .= "$tem\n\n$exp\n";
  
  return $r;
}

sub usagePrint {
  my $tablen = shift;
  my $width = shift;
  my $string = shift;
  
  my $chars = ($width - 12 - $tablen);
  my $tab = (' ' x $tablen);
  $string =~ s/(.{$chars}\S*)\s/$1\n$tab/g;
  
  return $string;
}

# Read all arguments in @_ and set all argument globals. Return a hash 
# containing the supplied arguments if successful. If unexpected 
# arguments are found an abort message is output and undef is returned.
sub arguments {
  no strict 'refs';
  
  # First set globals to default values
  foreach my $s ('all', $SCRIPT_NAME) {
    foreach my $t (keys %{$ARG{$s}}) {
      foreach my $a (keys %{$ARG{$s}{$t}}) {
        my $n = @{$ARG{$s}{$t}{$a}}[0];
        my $v = @{$ARG{$s}{$t}{$a}}[1];
        $$n = $v
      }
    }
  }
  
  my $switchRE = '^(' . 
    join('|', map(keys %{$ARG{$_}{'switch'}}, 'all', $SCRIPT_NAME)) . 
    ')$';
  
  my $optionRE = '^(' . 
    join('|', map(keys %{$ARG{$_}{'option'}}, 'all', $SCRIPT_NAME)) . 
    ')$';
  
  my %args;
  
  # Now update globals based on the provided arguments.
  my $arg = shift;
  my @a = ('first', 'second', 'third', 'fourth', 'fifth'); $a = 0;
  while ($arg) {
    if ($arg =~ /^\-(\S*)/) {
      my $f = $1;
      if    ($f =~ /$switchRE/) {
        $$1 = !$$1; $args{$1} = $$1;
      }
      elsif ($f =~ /$optionRE/) {
        my $v = shift; 
        if (!$v || $v =~ /^\-/) {
          print "\nABORT: option -$f needs a value\n";
          return;
        }
        $$1 = $v; $args{$1} = $$1;
      }
      else {
        print "\nABORT: unhandled option: $arg\n";
        return;
      }
    }
    else {
      my $name;
      if (@a[$a]) {
        foreach ('all', $SCRIPT_NAME) {
          if (!exists($ARG{'all'}{'argument'}{@a[$a]})) {next;}
          $name = $ARG{'all'}{'argument'}{@a[$a]}[0];
        }
      }
      if ($name) {
        $$name = $arg;
        $args{$name} = $$name;
        $a++;
      }
      else {
        print "\nABORT: too many arguments.\n";
        return;
      }
    }
    
    $arg = shift;
  }
  
  &DebugListVars("$SCRIPT_NAME arguments", 'HELP', 'INPD', 'LOGFILE', 
    'NO_ADDITIONAL', 'CONVERSION', 'MODRE', 'MAXTHREADS', 'SKIPRE');
  
  return %args;
}
