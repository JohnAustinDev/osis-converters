#!/usr/bin/perl

# Run specified conversions for any number of projects, as quickly as possible

use threads;
use threads::shared;

# Bootstrap osis-converters without init() so project config files can be read.
use strict; use File::Spec; our $SCRIPT = File::Spec->rel2abs(__FILE__); our $SCRD = $SCRIPT; $SCRD =~ s/([\\\/][^\\\/]+){2}$//; require "$SCRD/lib/common/bootstrap.pm";

my  $DEBUG = 0;
our $VAGRANT = 0;

my $MODRE_DEF = 'all'; 
my $CONVERSIONS_DEF = 'sfm2all';
my $LOG_DEF = './OUT_convert.txt';

my $USAGE = "
USAGE: convert [-h] [-x rx] [-s rx] [-c type] [-t N] [-l file] [dir]

dir     : Path to a directory containing one or more osis-converters 
          projects. Default is the working directory.
-c type : Conversion(s) to run. Default is '$CONVERSIONS_DEF'. The 
          choices are osis, sfm2osis, osis2osis, osis2sword, osis2html, 
          osis2ebooks, osis2gobible, osis2all sfm2sword, sfm2html, 
          sfm2ebooks, sfm2gobible and sfm2all.
-h      : Show this usage message an exit.
-l file : Log file. Default is $LOG_DEF in the working directory.
-s rx   : Regex matching modules to skip. Default is none.
-t N    : Number of threads to use. Default is the number of CPUs.
-x rx   : Regex matching modules to run, or 'all'. Default is '$MODRE_DEF'.
";

my ($PRJDIR, $MODRE, $CONVERSIONS, $MAXTHREADS, $SKIP, $MYLOG);
if (!&arguments(@ARGV)) {print $USAGE; exit;}

# Restart in Vagrant if necessary
my $isCompatibleLinux = ($^O =~ /linux/i ? `lsb_release -a 2>&1`:'');
if (!&runningInVagrant() && ($VAGRANT || !$isCompatibleLinux)) {
  &convertInVagrant();
}
if (&runningInVagrant()) {$VAGRANT = 1;}

use DateTime;
use Encode;
use File::Copy;
use Data::Dumper;
use Term::ReadKey;

# Config values may be set here to be applied to the config.conf of 
# every project converted by this script.
my %CONFIG; # $CONFIG{(MAINMOD|DICTMOD|section)}{config-entry} = value
#$CONFIG{'osis2ebooks'} {'CreateFullBible'} = 'false';
#$CONFIG{'osis2ebooks'} {'CreateSeparatePubs'} = 'false';
#$CONFIG{'osis2ebooks'} {'CreateSeparateBooks'} = 'first';
#$CONFIG{'osis2ebooks'} {'CreateTypes'} = 'epub';
#$CONFIG{'osis2html'}   {'CreateFullBible'} = 'false';
#$CONFIG{'osis2html'}   {'CreateSeparatePubs'} = 'false';
#$CONFIG{'osis2html'}   {'CreateSeparateBooks'} = 'first';
#$CONFIG{'osis2sword'}  {'ARG_skipConversion'} = 'true';
#$CONFIG{'osis2gobible'}{'ARG_skipConversion'} = 'true';
#$CONFIG{'osis2html'}   {'ARG_skipConversion'} = 'true';
#$CONFIG{'osis2ebooks'} {'ARG_skipConversion'} = 'true';
#$CONFIG{'MAINMOD'}     {'AddScripRefLinks'} = 'false';
#$CONFIG{'MAINMOD'}     {'AddDictLinks'} = 'false';
#$CONFIG{'MAINMOD'}     {'AddCrossRefLinks'} = 'false';
#$CONFIG{'DICTMOD'}     {'AddSeeAlsoLinks'} = 'false';
#$CONFIG{'system'}      {'DEBUG'} = '1';

$Data::Dumper::Sortkeys = 1;

my %PRINTED;
if (-e $MYLOG) {unlink($MYLOG);}

my $STARTTIME;
&timer('start'); &pLog("\n");

my $INFO = &getProjectsInfo($PRJDIR);

my @MODULES; my @MODULE_IGNORES;
my %MAINS;   my %MAIN_IGNORES;
foreach my $m (sort keys %{$INFO}) {
  if ($MODRE && $MODRE !~ /^all$/i && $m !~ /^$MODRE$/) {next;}
  if ($SKIP && $m =~ /$SKIP/) {next;}
  
  if ($INFO->{$m}{'runable'}) {
    push(@MODULES, $m);
    
    my $dict = &hasDICT($m);
    $MAINS{($dict && $dict =~ /^(.*?)DICT$/ ? $1:$m)}++;
  }
  else {
    push(@MODULE_IGNORES, $m);
    
    my $dict = &hasDICT($m);
    $MAIN_IGNORES{($dict && $dict =~ /^(.*?)DICT$/ ? $1:$m)}++;
  }
}

&pLog("Ignoring ".(scalar keys %MAIN_IGNORES)." projects which need upgrading (".@MODULE_IGNORES." modules):\n");
foreach my $m (@MODULE_IGNORES) {
  &pLog(sprintf("%12s\n", $m));
}
&pLog("\n");

# Update config files with any global changes, and then re-read info.
if (keys %CONFIG) {&updateConfigFiles(\@MODULES, \%CONFIG, $INFO);}
$SIG{'INT'} = sub {&finish()};
$INFO = &getProjectsInfo($PRJDIR);
if ($DEBUG) {&pLog("INFO = ".Dumper($INFO)."\n");}

# If any module is running in Vagrant, be sure we're in Vagrant mode or
# the console will lock up.
my $v;
foreach (keys %{$INFO}) {if ($VAGRANT || $INFO->{$_}{'system+VAGRANT'}) {$v++;}}
if ($v) {
  $VAGRANT = 1;
  print "NOTE: Running $VAGRANT project(s) in Vagrant...\n";
}

my @RUN = &getScriptsToRun(\@MODULES, $CONVERSIONS, $INFO);

my %DEPENDENCY; &setDependencies(\%DEPENDENCY, \@RUN, $CONVERSIONS, $INFO, \@MODULES);

&pLog("Scheduling ".@RUN." jobs on ".(scalar keys %MAINS)." projects (".@MODULES." modules):\n");
foreach my $m (@MODULES) {
  foreach my $rP (@RUN) {
    my $run = $rP->{'s'}.' '.$rP->{'m'};
    if ($run !~ /^(\S+)\s+$m$/) {next;}
    my $script = $1;
    my $deps = join(', ', @{$DEPENDENCY{$run}});
    my $depsmsg = ($deps ? "(after $deps)":'');
    $depsmsg =~ s/ (osis2osis|sfm2osis)//g;
    &pLog(sprintf("%12s:%12s %-35s %s\n", 
                  $m, 
                  $script,
                  $depsmsg, 
                  &outdir($INFO, $m)
    ));
  }
}
&pLog("\n");

if (! scalar @RUN) {
  print "ABORT: There is nothing to do.\n";
  print $USAGE;
  exit;
}

if (!$VAGRANT && scalar keys %MAINS > 1) {
  print "Do you want to continue? (Y/N): ";
  my $resp = <STDIN>;
  if ($resp !~ /^y(es)?$/i) {
    print "Exiting...\n";
    exit;
  }
}

if (!$VAGRANT) {ReadMode 4;}

# Now run all jobs until there is nothing left to do, or the ESC key is 
# pressed.
&pLog("Running ".@RUN." jobs on ".(scalar keys %MAINS)." projects (".@MODULES." modules):\n");
my $NUM_THREADS :shared = 0;
my %DONE :shared;
my @STARTED :shared;
my $WAIT = 3;
my $KEY = 0;
my $PAUSED = 0;
my $KILLED = 0;
while ( ( &working(\@STARTED, \%DONE) || @RUN ) && 
          $KEY != 27 
      ) { # 27 is ESC key
      
  $KEY = 0; # clear if set by inner while loop
  while ( !$PAUSED && $KEY != 27 && $NUM_THREADS < $MAXTHREADS && @RUN ) {
    # Start another conversion, skipping over any conversion whose 
    # dependencies are not done.
    my $x = -1;
    my $ok;
    do {
      $x++;
      $ok = 1;
      foreach my $run (@{$DEPENDENCY{$RUN[$x]->{'r'}}}) {
        if (!$DONE{$run}) {$ok = 0;}
      }
    } while ($x < $#RUN && !$ok);
    
    if (@{$DEPENDENCY{$RUN[$x]->{'r'}}}) {
      if (!$ok) {
        print "Waiting for dependencies (".($MAXTHREADS - $NUM_THREADS)." free threads)...\n".
        last;
      }
      print "NOTE: Dependencies of ".$RUN[$x]->{'r'}." are done:\n\t".
      join("\n\t", @{$DEPENDENCY{$RUN[$x]->{'r'}}})."\n";
    }
    
    sleep(2); # so jobs don't start at the same time, causing problems
    threads->create(sub {
      print "Starting: ".$RUN[$x]->{'r'}."\n";
      &runScript($RUN[$x]);
      $NUM_THREADS--;
      $DONE{$RUN[$x]->{'r'}}++;
      print "Exiting: ".$RUN[$x]->{'r'}."\n";
    });
    
    $NUM_THREADS++;
    my $s = splice(@RUN, $x, 1);
    push(@STARTED, $s->{'r'});
    if (@RUN) {print("There are ".@RUN." jobs left...\n");}
    
    &readKey();
  }

  if (!$KEY) {  # allow KEY already set by inner while loop to break outer loop
    &readKey();
  }
  sleep(2);
}

if (!$VAGRANT) {ReadMode 0;}

if ($KEY == 27) {
  &pLog("\n");
  &pLog("
No more conversions will be scheduled...
Press ctrl-c to kill remaining threads and exit.
Or wait for the current threads to finish:\n");
&working(\@STARTED, \%DONE, 'log');
}
else {
  print "No more projects to start and none are running!\n";
}

&finish();

########################################################################
########################################################################

# Fill a hash with config.conf and CF_osis2osis.txt information for all
# projects in $pdir
sub getProjectsInfo {
  my $pdir = shift;
  
  opendir(DIR, $pdir) or die;
  my @projects = readdir(DIR);
  closedir(DIR);
  
  my %info;
  foreach my $proj (@projects) {
    if ($proj eq '..' || !-d "$pdir/$proj") {next;}
    if ($proj eq '.') {
      $proj = ($pdir =~ s/\/([A-Z]+)$// ? $1:'');
      if (!$proj) {next;}
    }
    if (! -e "$pdir/$proj/CF_osis2osis.txt" && ! -e "$pdir/$proj/config.conf") {next;}
    &getProjectInfo($pdir, $proj, \%info);
  }
  
  # Create info for dict modules now
  foreach my $proj (keys %info) {
    if (!&hasDICT($proj, \%info)) {next;}
    # Only runnable DICT modules are returned by hasDICT()
    $info{$proj.'DICT'}{'runable'}++;
    $info{$proj.'DICT'}{'path'} = $info{$proj}{'path'}."/${proj}DICT";
    $info{$proj.'DICT'}{'configProject'} = $info{$proj}{'configProject'};
    if ($info{$proj}{'sourceProject'}) {
      $info{$proj.'DICT'}{'sourceProject'} = $info{$proj}{'sourceProject'};
    }
  }
  
  # Add module types
  foreach my $m (keys %info) {
    if (!$info{$m}{'runable'}) {next;}
    
    my $cp = $info{$m}{'configProject'};
    my $cpm = ($m =~ /DICT$/ ? $cp.'DICT':$cp);
    my $moddrv = $info{$cp}{"$cpm+ModDrv"};
    
    if (!$moddrv) {
      my $sp = $info{$m}{'sourceProject'};
      my $spm = ($m =~ /DICT$/ ? $sp.'DICT':$sp);
      $moddrv = $info{$sp}{"$spm+ModDrv"};
    }
    
    my $type;
    if    ($moddrv =~ /text/i)    {$type = 'bible';}
    elsif ($moddrv =~ /ld/i)      {$type = 'dict';}
    elsif ($moddrv =~ /genbook/i) {$type = 'childrensBible';}
    elsif ($moddrv =~ /com/i)     {$type = 'commentary';}
    else {print "WARNING: Could not determine module type: $m\n";}
    
    $info{$m}{'type'} = $type;
  }

  return \%info;
}

sub getProjectInfo {
  my $pdir = shift;
  my $proj = shift;
  my $infoP = shift;

  # - sourceProject is osis2osis source project, or else undef 
  # if OSIS will be created by sfm2osis (the usual case).
  # - configProject is the the MAIN module of a project if it has a
  # config.conf or else the MAIN module of the sourceProject if there 
  # is a sourceProject with a config.conf (projects with a 
  # CF_osis2osis.txt file might not have their own config.conf file 
  # until after osis2osis is run, so this script may reference the 
  # sourceProject's config.conf in such a case).
  
  if (-e "$pdir/$proj/CF_osis2osis.txt") {
    open(CF, "<:encoding(UTF-8)", "$pdir/$proj/CF_osis2osis.txt") 
      or die;
    while(<CF>) {
      if ($_ =~ /^SET_sourceProject:(.*?)\s*$/) {
        my $sourceProject = $1;
        # If CF_osis2osis.txt has SET_sourceProject, its modules are
        # considered runnable.
        $infoP->{$proj}{'runable'}++;
        $infoP->{$proj}{'path'} = "$pdir/$proj";
        $infoP->{$proj}{'sourceProject'} = $sourceProject;
        $infoP->{$proj}{'configProject'} = $sourceProject;
      }
      if ($_ =~ /^CCOSIS\:\s*(\S+)\s*$/) {
        $infoP->{$proj}{'CCOSIS'}{$1}++;
      }
    }
    close(CF);
  }
  
  if (!-e "$pdir/$proj/config.conf") {return;}
  $infoP->{$proj}{'configProject'} = $proj;
  
  # Projects where config.conf contains [system] are considered runnable
  my $cp = $infoP->{$proj}{'configProject'};
  if (&shell("grep '\\[system\\]' \"$pdir/$cp/config.conf\"", 3, 1)) {
    $infoP->{$proj}{'runable'}++;
    $infoP->{$proj}{'path'} = "$pdir/$proj";
    if (!defined($infoP->{$cp}{'MainmodName'})) {
      our $CONF; &set_configuration_globals("$pdir/$cp", 'none');
      foreach my $k (keys %{$CONF}) {$infoP->{$cp}{$k} = $CONF->{$k};}
    }
  }
}

sub getScriptsToRun {
  my $projectsAP = shift;
  my $script = shift;
  my $infoP = shift;
  
  my @run;
  
  # Certain module types have a limited set of scripts that can be run on them.
  my @bible = ('sfm2osis', 'osis2osis', 'osis', 'osis2sword', 'osis2html', 'osis2ebooks', 'osis2gobible');
  my @dict = ('sfm2osis', 'osis2osis', 'osis', 'osis2sword');
  my @childrensBible = ('sfm2osis', 'osis2osis', 'osis', 'osis2sword', 'osis2html', 'osis2ebooks');
  my @commentary = ('sfm2osis', 'osis2osis', 'osis', 'osis2sword'); # never tried!: 'osis2html', 'osis2ebooks';
  
  my @sfm2all = @bible; splice(@sfm2all, 0, 2);
  my @osis2all = @bible; splice(@osis2all, 0, 3);
  
  my $scriptAP = ($script eq 'sfm2all' ? \@sfm2all:\@osis2all);
  
  # Assign scripts to be run
  foreach my $m (@{$projectsAP}) {
    my $type = $infoP->{$m}{'type'};
    my $typeAP;
    if    ($type eq 'bible')          {$typeAP = \@bible;}
    elsif ($type eq 'dict')           {$typeAP = \@dict;}
    elsif ($type eq 'childrensBible') {$typeAP = \@childrensBible;}
    elsif ($type eq 'commentary')     {$typeAP = \@commentary;}
    else {next;}
    
    if ($script =~ /^(osis2all|sfm2all)$/) {
      foreach my $scr (@{$scriptAP}) {
        foreach my $ok (@{$typeAP}) {
          if ($scr ne $ok) {next;}
          my $s = ($scr eq 'osis' ? &osisScript($m):$scr);
          my $arg = $infoP->{$infoP->{$m}{'configProject'}}{"$s+ARG_skipConversion"};
          if ($arg && $arg =~ /^(true|yes)$/i) {
            print "WARNING: Skipping '$s $m' because config.conf ARG_skipConversion = true\n";
            next;
          }
          push(@run, {'r' => "$s $m",
                      's' => $s, 
                      'm' => $m, 
                      'p' => $infoP->{$m}{'path'} });
        }
      }
    }
    elsif ($script =~ /^sfm2(sword|html|ebooks|GoBible)$/) {
      my $to = $1;
      push(@run, {'r' => &osisScript($m)." $m",
                  's' => &osisScript($m), 
                  'm' => $m, 
                  'p' => $infoP->{$m}{'path'} });
      foreach my $ok (@{$typeAP}) {
        if ("osis2$to" ne $ok) {next;}
        push(@run, {'r' => "osis2$to $m",
                    's' => "osis2$to", 
                    'm' => $m, 
                    'p' => $infoP->{$m}{'path'} });
      }
    }
    else {
      foreach my $ok (@{$typeAP}) {
        if ($script ne $ok) {next;}
        my $s = $script;
        if ($script eq 'osis') {$s = &osisScript($m);}
        elsif ($script =~ /^(sfm2osis|osis2osis)$/) {
          if ($s ne &osisScript($m)) {next;}
        }
        push(@run, {'r' => "$s $m", 
                    's' => $s, 
                    'm' => $m, 
                    'p' => $infoP->{$m}{'path'} });
      }
    }
  }
  
  return @run;
}

# Set dependencies for each conversion. Each dependency is a string with 
# script and module, like: "$s $m", such that the given script must be 
# run on the given module before that dependency is considered met. Each
# conversion has an array of these dependencies, all of which need to be
# met before the conversion should be run.
sub setDependencies {
  my $depsHP = shift;
  my $runAP = shift;
  my $script = shift;
  my $infoP = shift;
  my $modulesAP = shift;
    
  foreach my $rP (@{$runAP}) {
    my $r = $rP->{'r'}; my $s = $rP->{'s'}; my $m = $rP->{'m'};
    
    $depsHP->{$r} = [];
    
    my %deps;
    
    # run's requiring the OSIS files to be rebuilt...
    if ($script =~ /^(osis|osis2osis)$/ || $script =~ /^sfm2/) {
      if ($s eq 'sfm2osis' || $script eq 'osis2osis') {
        # sfm2osis DICT sub-modules depend on main OSIS
        if ($m eq &hasDICT($m)) {
          my $main = $m; $main =~ s/DICT$//;
          $deps{&osisScript($main).' '.$main}++;
        }
      }
      elsif ($s eq 'osis2osis') {
        # osis2osis modules depend on their source main & dict OSIS and 
        # possibly their main OSIS (if a DICT)
        my $sproj = $infoP->{$m}{'sourceProject'};
        $deps{&osisScript($sproj).' '.$sproj}++;
        if (my $dict = &hasDICT($sproj)) {
          $deps{&osisScript($dict).' '.$dict}++;
        }
        if ($m eq &hasDICT($m)) {
          my $main = $m; $main =~ s/DICT$//;
          $deps{&osisScript($main).' '.$main}++;
        }
      }
      elsif ($s =~ /^(osis2gobible|osis2sword)$/) {
        # these depend only on their OSIS file
        $deps{&osisScript($m).' '.$m}++;
      }
      elsif ($s =~ /^(osis2html|osis2ebooks)$/) {
        # these depend on both main and dict (if exists) OSIS files
        $deps{&osisScript($m).' '.$m}++;
        if (my $dict = &hasDICT($m)) {
          $deps{&osisScript($dict).' '.$dict}++;
        }
      }
    }
    
    if ($s =~ /^(osis2sword)$/) {
      # The main SWORD module must be created first, because its links 
      # to the dict SWORD module are checked when the dict is created.
      if ($m eq &hasDICT($m)) {
        my $main = $m; $main =~ s/DICT$//;
        $deps{"osis2sword $main"}++;
      }
    }
    
    # include only those dependencies which are part of the current run
    my %modules; map($modules{$_}++, @{$modulesAP});
    foreach my $d (keys %deps) {
      if ($d !~ /^(\S+)\s+(\S+)$/) {next;}
      my $s = $1; my $m = $2;
      if (!exists($modules{$m})) {
        print "WARNING: Skipping '$d' because $m is not being run.\n";
        next;
      }
      
      push(@{$depsHP->{$r}}, $d);
    }
  }
  
  if ($DEBUG) {&pLog("DEPENDENCIES = ".Dumper($depsHP)."\n");}
}

# Run osis-converters on a module, and report.
sub runScript {
  my $rP = shift;
  
  my $script = $rP->{'s'};
  my $path   = $rP->{'p'};
  my $mod    = $rP->{'m'};
  
  my $cmd = "$SCRD/bin/$script \"$path\"";
  print "Started: $cmd\n";
  my $result = decode('utf8', `$cmd  2>&1`);

  my @errors;
  foreach my $line (split(/\n+/, $result)) {
    if ($line !~ /ERROR/) {next;}
    push(@errors, "$mod $line");
  }
  
  if (@errors) {
    &pLog(sprintf("\nFAILED:  %12s %9s FINISHED WITH %i ERROR(s).\n", 
          $script, 
          $mod, 
          scalar @errors
    ));
    foreach my $e (@errors) {&pLog("$e\n");}
    &pLog("\n");
    return;
  }
  
  &pLog(sprintf("SUCCESS! %12s %9s is FINISHED.\n", 
        $script, 
        $mod
  ));
}

sub updateConfigFiles {
  my $projAP = shift;
  my $configHP = shift;
  my $infoP = shift;
  my $restore = shift;
  
  if (!(scalar keys %{$configHP})) {
    &pLog("No config.conf changes to be made.\n\n");
    return;
  }
  
  if (!$restore) {
    &pLog("Config changes which are being applied to config.conf files: ".
      Dumper($configHP)."\n");
      
    # Gather a list of unique config files to update
    my %update;
    foreach my $m (@{$projAP}) {
      $update{$infoP->{$m}{'configProject'}}++;
      if ($infoP->{$m}{'sourceProject'}) {
        $update{$infoP->{$m}{'sourceProject'}}++;
      }
    }
    
    # Update each config file in turn
    foreach my $m (keys %update) {
      &copy("$PRJDIR/$m/config.conf", "$PRJDIR/$m/.config.conf.bak") 
        or die "Move failed: $!";
      open(INC, "<:encoding(UTF-8)", "$PRJDIR/$m/.config.conf.bak") 
        or die "Could not read: $!";
      open(OUTC, ">:encoding(UTF-8)", "$PRJDIR/$m/config.conf") 
        or die "Could not write: $!";
      
      my $section = $m;
      while(<INC>) {
        if ($_ =~ /^\[([^\]]+)\]\s*$/) {
          $section = $1;
        }
        elsif ($_ =~ /^([^#]\S*)\s*=\s*(.*?)\s*$/) {
          my $e = $1; my $v = $2;
          foreach my $sc (keys %{$configHP}) {
            my $sec = $sc;
            my $mod = ($sec =~ s/^([^:]+):// ? $1:'');
            foreach my $ec (keys %{$configHP->{$sc}}) {
              if ( $sec eq $section && $ec eq $e &&
                    (!$mod || $mod eq $m) ) {
                $_ = '#'.$_;
                print "Commenting $m config.conf: $_";
              }
            }
          }
        }
        print OUTC $_;
      }
      close(INC);
      
      print OUTC "\n";
      foreach my $sc (keys %{$configHP}) {
        my $sec = $sc;
        my $mod = ($sec =~ s/^([^:]+):// ? $1:'');
        if ($sc eq 'MAINMOD') {$sec = $m;}
        elsif ($sc eq 'DICTMOD') {$sec = $m.'DICT';}
        foreach my $ec (keys %{$configHP->{$sc}}) {
          if ($mod && $mod ne $m) {next;}
          my $l1 = "[$sec]"; my $l2 = "$ec = ".$configHP->{$sc}{$ec};
          print "Appending to $m config.conf: $l1 $l2\n";
          print OUTC "$l1\n$l2\n\n";
        }
      }
      close(OUTC);
      
    }
    &pLog("Changed ".(scalar keys %update)." config.conf files.\n");
  }
  else {
    my @fs = split(/\n+/, &shell("find \"$PRJDIR\" -name .config.conf.bak"));
    foreach my $f (@fs) {
      my $t = $f; $t =~ s/\.(config\.conf)\.bak$/$1/;
      &move("$PRJDIR/$f", "$PRJDIR/$t");
    }
    &pLog("Restored ".@fs." config.conf files.\n");
  }
  &pLog("\n");
  
}

# Returns the DICT sub-module name if the module is or has a DICT 
# sub-module.
sub hasDICT {
  my $m = shift;
  my $infoP = shift;
  
  $infoP = ($infoP ? $infoP:$INFO);
  
  # Only runable projects can have dictionaries
  my $dict;
  if ($infoP->{$m}{'runable'}) {
  
    # If this project has a sourceProject, we must look at 
    # sourceProject's conf.
    my $sproj = ( $infoP->{$m}{'sourceProject'} ? 
      $infoP->{$m}{'sourceProject'}:$infoP->{$m}{'configProject'} );
   
    # It must have a sub-module which follows all the rules.
    my $modDrv = $infoP->{$sproj}{$sproj."DICT+ModDrv"};
    if ($modDrv && $modDrv =~ /LD/) {
      $dict = ($m !~ /DICT$/ ? $m.'DICT':$m);
    }
  }

  return $dict;
}

# Returns the script used to create the module's OSIS file (sfm2osis or 
# osis2osis)
sub osisScript {
  my $m = shift;
  
  if (!$INFO->{$m}{'sourceProject'}) {
    return 'sfm2osis';
  }
  
  if (!&hasDICT($m)) {
    return 'osis2osis';
  }
  
  my $main = $m; $main =~ s/DICT$//;
  return ($INFO->{$main}{'CCOSIS'}{$m} ? 'osis2osis':'sfm2osis');
}

# Return the output directory where the OSIS file will go.
sub outdir {
  my $infoP = shift;
  my $m = shift;
  
  my $p = $m; $p =~ s/DICT$//;
  
  my $outdir = $infoP->{$p}{'system+OUTDIR'};
  if ($infoP->{$p}{'sourceProject'}) {
    $outdir = $infoP->{$infoP->{$p}{'sourceProject'}}{'system+OUTDIR'};
  }
  
  $outdir = ( $outdir ? $outdir : 
              "$PRJDIR/$p/".($m =~ /DICT$/ ? "$m/":'')."outdir"
            );
  
  return $outdir;
}

sub timer {
  my $do = shift;
 
  if ($do =~ /start/i) {
    &pLog("start time: ".localtime()."\n");
    $STARTTIME = DateTime->now();
  }
  elsif ($do =~ /stop/i) {
    &pLog("\nend time: ".localtime()."\n");
    if ($STARTTIME) {
      my $now = DateTime->now();
      my $e = $now->subtract_datetime($STARTTIME);
      &pLog("elapsed time: ".
            ($e->hours ? $e->hours." hours ":'').
            ($e->minutes ? $e->minutes." minutes ":'').
            $e->seconds." seconds\n");
    }
    $STARTTIME = '';
  }
  else {&pLog("\ncurrent time: ".localtime()."\n");}
}

# Return the number of projects currently running, and print or log a 
# message about the currently running projects.
my $LASTMSG;
sub working {
  my $startedAP = shift;
  my $doneHP = shift;
  my $logOrPrint = shift; # 'log' means log msg. Otherwise print msg. 

  my @working;
  foreach my $r (@{$startedAP}) {
    if (!$doneHP->{$r}) {push(@working, $r);}
  }
  
  if ($logOrPrint || !$WAIT) {
    my $msg = "Working on: \n\t".join("\n\t", @working)."\n";
    if (!$VAGRANT) {
      if (!$PAUSED) {
        $msg .= "Press p to pause the scheduler. ";
      }
      else {
        $msg .= "Press p again to continue scheduling. ";
      }
      if (!$KILLED) {
        $msg .= "Press ESC to kill the scheduler.\n";
      }
    }
    
    if ($logOrPrint && $logOrPrint =~ /log/i) {&pLog($msg);}
    elsif ($msg ne $LASTMSG) {
      print $msg;
      $LASTMSG = $msg;
    }
    
    $WAIT = 15; # 30 seconds at 2 second sleeps
  }
  
  $WAIT--;
  
  return scalar @working;
}

sub readKey {
  if ($VAGRANT) {return;}
  $KEY = ReadKey(-1);
  $KEY = ($KEY ? ord($KEY):0);
  if ($KEY == 112) {
    $PAUSED = ($PAUSED ? 0:1);
    if ($PAUSED) {
      print "\nThe scheduler is currently PAUSED.\n";
    }
    else {
      print "\nRestarting the scheduler...\n";
    }
  }
  elsif ($KEY == 27) {
    $KILLED++;
    print "ESC was pressed...\n";
  }
}

sub finish {

  if (!$VAGRANT) {ReadMode 0;}
  
  foreach my $th (threads->list()) {$th->join();}

  if (keys %CONFIG) {
    &updateConfigFiles(\@MODULES, \%CONFIG, $INFO, 'restore');
  }

  &timer('stop');
  
  exit;
}

sub pLog {
  my $p = shift;

  print encode("utf8", $p);
  
  open(LOGF, ">>:encoding(UTF-8)", $MYLOG) || die;
  print LOGF $p;
  close(LOGF);
}

sub convertInVagrant {

  our $INPD = $PRJDIR; # necessary for initialize_vagrant() to work
  
  &initialize_vagrant();
  
  my $vscript = &vagrantPath($SCRIPT);
  if (!$vscript) {print "ABORT: failed vagrantPath: $SCRIPT\n"; exit;}
  my $vpdir   = &vagrantPath($PRJDIR);
  if (!$vpdir)   {print "ABORT: failed vagrantPath: $PRJDIR\n"; exit;}
  my $vlog    = &vagrantPath($MYLOG);
  if (!$vlog)    {print "ABORT: failed vagrantPath: $MYLOG\n";  exit;}
  
  my $cmd = "vagrant ssh -c \"".
            "'$vscript' ".
            "-x '$MODRE' ".
            "-s '$SKIP' ".
            "-c '$CONVERSIONS' ".
            "-l '$vlog' ".
            "'$vpdir'\"";

  print "\nStarting Vagrant with...\n$cmd\n";
  
  # Continue printing to console while Vagrant ssh remains open
  open(VUP, "$cmd |");
  while(<VUP>) {print $_;}
  close(VUP);
  
  exit;
}

sub arguments {
  $PRJDIR = ".";
  $MYLOG = "./$LOG_DEF";
  $MODRE = $MODRE_DEF;
  $SKIP = '^(none)$';
  $CONVERSIONS = $CONVERSIONS_DEF;
  $MAXTHREADS = `lscpu | egrep "^CPU\\(s\\)\\:"`; $MAXTHREADS =~ s/^.*?\s+(\d+)\s*$/$1/;

  my $arg = shift;
  while ($arg) {
    if ($arg =~ /^\-(\S*)/) {
      my $f = $1;
      if ($f eq 'h') {return;}
      elsif (!$f) {
        print "ABORT: no flag name: -\n";
        return;
      }
      
      my $v = shift; if (!$v || $v =~ /^\-/) {
        print "ABORT: flag -$f has no value\n";
        return;
      }
      
      if ($f eq 'c' && $v =~ /^(osis|sfm2osis|osis2osis|osis2sword|osis2html|osis2ebooks|osis2gobible|osis2all|sfm2sword|sfm2html|sfm2ebooks|sfm2gobible|sfm2all)$/) {
        $CONVERSIONS = $v;
      }
      elsif ($f eq 'l') {
        my $dir = ($v =~ /^(.*)[\\\/][^\\\/]+$/ ? $1:'');
        if (!$dir || ! -d $dir) {
          print "ABORT: log file directory does not exist: $v\n";
          return;
        }
        $MYLOG = $v;
      }
      elsif ($f eq 's') {$SKIP = $v;}
      elsif ($f eq 't' && $v =~ /^\d+$/) {$MAXTHREADS = $v;}
      elsif ($f eq 'x') {$MODRE = $v;}
      else {
        print "ABORT: unhandled flag: -$f $v\n";
        return;
      }
    }
    elsif (-d $arg) {$PRJDIR = $arg;}
    else {
      print "ABORT: not a directory: $arg\n";
      return;
    }
    
    $arg = shift;
  }
  
  if ($PRJDIR =~ /^\./) {$PRJDIR = File::Spec->rel2abs($PRJDIR);}
  if ($MYLOG =~ /^\./)  {$MYLOG  = File::Spec->rel2abs($MYLOG);}
  if ($MODRE =~ /^[A-Z]+$/ && $MODRE !~ /DICT$/) {
    $MODRE = '^'.$MODRE.'(DICT)?$';
  }
  
  return 1;
}
